/// Function is function runs within environment runtime with given package and secrets/configmaps.
///
/// This module was generated from the CustomResourceDefinition at
/// <file:///Users/lucsoft/Developer/infra-hmsys-sys/packages/io.Fission/>.
module io.fission.v1.Function

extends "@k8s/K8sResource.pkl"

import "@k8s/apimachinery/pkg/apis/meta/v1/ObjectMeta.pkl"
import "@k8s/api/core/v1/PodSpec.pkl"

fixed apiVersion: "fission.io/v1"

fixed kind: "Function"

/// Standard object's metadata.
///
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>.
metadata: ObjectMeta?

/// FunctionSpec describes the contents of the function.
spec: Spec

/// FunctionSpec describes the contents of the function.
class Spec {
  /// InvokeStrategy is a set of controls which affect how function executes
  InvokeStrategy: InvokeStrategy

  /// Maximum number of pods to be specialized which will serve requests This is optional. If not
  /// specified default value will be taken as 500
  concurrency: Int?

  /// Reference to a list of configmaps.
  configmaps: Listing<Configmap>?

  /// Environment is the build and runtime environment that this function is associated with. An
  /// Environment with this name should exist, otherwise the function cannot be invoked.
  environment: Environment

  /// FunctionTimeout provides a maximum amount of duration within which a request for a particular
  /// function execution should be complete. This is optional. If not specified default value will be
  /// taken as 60s
  functionTimeout: Int?

  /// IdleTimeout specifies the length of time that a function is idle before the function pod(s) are
  /// eligible for deletion. If no traffic to the function is detected within the idle timeout, the
  /// executor will then recycle the function pod(s) to release resources.
  idletimeout: Int?

  /// OnceOnly specifies if specialized pod will serve exactly one request in its lifetime and would be
  /// garbage collected after serving that one request This is optional. If not specified default value
  /// will be taken as false
  onceOnly: Boolean?

  /// Reference to a package containing deployment and optionally the source.
  package: Package

  /// Podspec specifies podspec to use for executor type container based functions Different arguments
  /// mentioned for container based function are populated inside a pod.
  podspec: PodSpec?

  /// RequestsPerPod indicates the maximum number of concurrent requests that can be served by a
  /// specialized pod This is optional. If not specified default value will be taken as 1
  requestsPerPod: Int?

  /// cpu and memory resources as per K8S standards This is only for newdeploy to set up resource
  /// limitation when creating deployment for a function.
  resources: Resources?

  /// RetainPods specifies the number of specialized pods that should be retained after serving requests
  /// This is optional. If not specified default value will be taken as 0
  retainPods: Int?

  /// Reference to a list of secrets.
  secrets: Listing<Secret>?
}

/// InvokeStrategy is a set of controls which affect how function executes
class InvokeStrategy {
  /// ExecutionStrategy specifies low-level parameters for function execution, such as the number of
  /// instances.
  ExecutionStrategy: ExecutionStrategy?

  /// StrategyType is the strategy type of function. Now it only supports 'execution'.
  StrategyType: String?
}

/// ExecutionStrategy specifies low-level parameters for function execution, such as the number of
/// instances.
class ExecutionStrategy {
  /// ExecutorType is the executor type of function used. Defaults to "poolmgr".
  ///
  /// Available value: - poolmgr - newdeploy - container
  ExecutorType: String?

  /// This is only for newdeploy to set up maximum replicas of deployment.
  MaxScale: Int?

  /// This is only for newdeploy to set up minimum replicas of deployment.
  MinScale: Int?

  /// This is the timeout setting for executor to wait for pod specialization.
  SpecializationTimeout: Int?

  /// Deprecated: use hpaMetrics instead. This is only for executor type newdeploy and container to set
  /// up target CPU utilization of HPA. Applicable for executor type newdeploy and container.
  TargetCPUPercent: Int?

  /// hpaBehavior is the behavior of HPA when scaling in up/down direction. Applicable for executor type
  /// newdeploy and container.
  hpaBehavior: HpaBehavior?

  /// hpaMetrics is the list of metrics used to determine the desired replica count of the Deployment
  /// created for the function. Applicable for executor type newdeploy and container.
  hpaMetrics: Listing<HpaMetric>?
}

/// hpaBehavior is the behavior of HPA when scaling in up/down direction. Applicable for executor type
/// newdeploy and container.
class HpaBehavior {
  /// scaleDown is scaling policy for scaling Down. If not set, the default value is to allow to scale
  /// down to minReplicas pods, with a 300 second stabilization window (i.e., the highest recommendation
  /// for the last 300sec is used).
  scaleDown: ScaleDown?

  /// scaleUp is scaling policy for scaling Up. If not set, the default value is the higher of: *
  /// increase no more than 4 pods per 60 seconds * double the number of pods per 60 seconds No
  /// stabilization is used.
  scaleUp: ScaleUp?
}

/// scaleDown is scaling policy for scaling Down. If not set, the default value is to allow to scale down
/// to minReplicas pods, with a 300 second stabilization window (i.e., the highest recommendation for the
/// last 300sec is used).
class ScaleDown {
  /// policies is a list of potential scaling polices which can be used during scaling. If not set, use
  /// the default values: - For scale up: allow doubling the number of pods, or an absolute change of 4
  /// pods in a 15s window. - For scale down: allow all pods to be removed in a 15s window.
  policies: Listing<Policy>?

  /// selectPolicy is used to specify which policy should be used. If not set, the default value Max is
  /// used.
  selectPolicy: String?

  /// stabilizationWindowSeconds is the number of seconds for which past recommendations should be
  /// considered while scaling up or scaling down. StabilizationWindowSeconds must be greater than or
  /// equal to zero and less than or equal to 3600 (one hour). If not set, use the default values: - For
  /// scale up: 0 (i.e. no stabilization is done). - For scale down: 300 (i.e. the stabilization window
  /// is 300 seconds long).
  stabilizationWindowSeconds: Int?

  /// tolerance is the tolerance on the ratio between the current and desired metric value under which no
  /// updates are made to the desired number of replicas (e.g. 0.01 for 1%). Must be greater than or
  /// equal to zero. If not set, the default cluster-wide tolerance is applied (by default 10%).
  ///
  /// For example, if autoscaling is configured with a memory consumption target of 100Mi, and scale-down
  /// and scale-up tolerances of 5% and 1% respectively, scaling will be triggered when the actual
  /// consumption falls below 95Mi or exceeds 101Mi.
  ///
  /// This is an alpha field and requires enabling the HPAConfigurableTolerance feature gate.
  tolerance: (Int|String)?
}

/// HPAScalingPolicy is a single policy which must hold true for a specified past interval.
class Policy {
  /// periodSeconds specifies the window of time for which the policy should hold true. PeriodSeconds
  /// must be greater than zero and less than or equal to 1800 (30 min).
  periodSeconds: Int

  /// type is used to specify the scaling policy.
  type: String

  /// value contains the amount of change which is permitted by the policy. It must be greater than zero
  value: Int
}

/// scaleUp is scaling policy for scaling Up. If not set, the default value is the higher of: * increase
/// no more than 4 pods per 60 seconds * double the number of pods per 60 seconds No stabilization is
/// used.
class ScaleUp {
  /// policies is a list of potential scaling polices which can be used during scaling. If not set, use
  /// the default values: - For scale up: allow doubling the number of pods, or an absolute change of 4
  /// pods in a 15s window. - For scale down: allow all pods to be removed in a 15s window.
  policies: Listing<Policy>?

  /// selectPolicy is used to specify which policy should be used. If not set, the default value Max is
  /// used.
  selectPolicy: String?

  /// stabilizationWindowSeconds is the number of seconds for which past recommendations should be
  /// considered while scaling up or scaling down. StabilizationWindowSeconds must be greater than or
  /// equal to zero and less than or equal to 3600 (one hour). If not set, use the default values: - For
  /// scale up: 0 (i.e. no stabilization is done). - For scale down: 300 (i.e. the stabilization window
  /// is 300 seconds long).
  stabilizationWindowSeconds: Int?

  /// tolerance is the tolerance on the ratio between the current and desired metric value under which no
  /// updates are made to the desired number of replicas (e.g. 0.01 for 1%). Must be greater than or
  /// equal to zero. If not set, the default cluster-wide tolerance is applied (by default 10%).
  ///
  /// For example, if autoscaling is configured with a memory consumption target of 100Mi, and scale-down
  /// and scale-up tolerances of 5% and 1% respectively, scaling will be triggered when the actual
  /// consumption falls below 95Mi or exceeds 101Mi.
  ///
  /// This is an alpha field and requires enabling the HPAConfigurableTolerance feature gate.
  tolerance: (Int|String)?
}

/// MetricSpec specifies how to scale based on a single metric (only `type` and one other matching field
/// should be set at once).
class HpaMetric {
  /// containerResource refers to a resource metric (such as those specified in requests and limits)
  /// known to Kubernetes describing a single container in each pod of the current scale target (e.g. CPU
  /// or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of
  /// those available to normal per-pod metrics using the "pods" source.
  containerResource: ContainerResource?

  /// external refers to a global metric that is not associated with any Kubernetes object. It allows
  /// autoscaling based on information coming from components running outside of cluster (for example
  /// length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster).
  `external`: External?

  /// object refers to a metric describing a single kubernetes object (for example, hits-per-second on an
  /// Ingress object).
  object: Object?

  /// pods refers to a metric describing each pod in the current scale target (for example,
  /// transactions-processed-per-second). The values will be averaged together before being compared to
  /// the target value.
  pods: Pods?

  /// resource refers to a resource metric (such as those specified in requests and limits) known to
  /// Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such metrics are
  /// built in to Kubernetes, and have special scaling options on top of those available to normal
  /// per-pod metrics using the "pods" source.
  resource: Resource?

  /// type is the type of metric source. It should be one of "ContainerResource", "External", "Object",
  /// "Pods" or "Resource", each mapping to a matching field in the object.
  type: String
}

/// containerResource refers to a resource metric (such as those specified in requests and limits) known
/// to Kubernetes describing a single container in each pod of the current scale target (e.g. CPU or
/// memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those
/// available to normal per-pod metrics using the "pods" source.
class ContainerResource {
  /// container is the name of the container in the pods of the scaling target
  container: String

  /// name is the name of the resource in question.
  name: String

  /// target specifies the target value for the given metric
  target: Target
}

/// target specifies the target value for the given metric
class Target {
  /// averageUtilization is the target value of the average of the resource metric across all relevant
  /// pods, represented as a percentage of the requested value of the resource for the pods. Currently
  /// only valid for Resource metric source type
  averageUtilization: Int?

  /// averageValue is the target value of the average of the metric across all relevant pods (as a
  /// quantity)
  averageValue: (Int|String)?

  /// type represents whether the metric type is Utilization, Value, or AverageValue
  type: String

  /// value is the target value of the metric (as a quantity).
  value: (Int|String)?
}

/// external refers to a global metric that is not associated with any Kubernetes object. It allows
/// autoscaling based on information coming from components running outside of cluster (for example
/// length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster).
class External {
  /// metric identifies the target metric by name and selector
  metric: Metric

  /// target specifies the target value for the given metric
  target: Target
}

/// metric identifies the target metric by name and selector
class Metric {
  /// name is the name of the given metric
  name: String

  /// selector is the string-encoded form of a standard kubernetes label selector for the given metric
  /// When set, it is passed as an additional parameter to the metrics server for more specific metrics
  /// scoping. When unset, just the metricName will be used to gather metrics.
  selector: Selector?
}

/// selector is the string-encoded form of a standard kubernetes label selector for the given metric When
/// set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
/// When unset, just the metricName will be used to gather metrics.
class Selector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates
/// the key and values.
class MatchExpression {
  /// key is the label key that the selector applies to.
  key: String

  /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists
  /// and DoesNotExist.
  operator: String

  /// values is an array of string values. If the operator is In or NotIn, the values array must be
  /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is
  /// replaced during a strategic merge patch.
  values: Listing<String>?
}

/// object refers to a metric describing a single kubernetes object (for example, hits-per-second on an
/// Ingress object).
class Object {
  /// describedObject specifies the descriptions of a object,such as kind,name apiVersion
  describedObject: DescribedObject

  /// metric identifies the target metric by name and selector
  metric: Metric

  /// target specifies the target value for the given metric
  target: Target
}

/// describedObject specifies the descriptions of a object,such as kind,name apiVersion
class DescribedObject {
  /// apiVersion is the API version of the referent
  apiVersion: String?

  /// kind is the kind of the referent; More info:
  /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  kind: String

  /// name is the name of the referent; More info:
  /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String
}

/// pods refers to a metric describing each pod in the current scale target (for example,
/// transactions-processed-per-second). The values will be averaged together before being compared to the
/// target value.
class Pods {
  /// metric identifies the target metric by name and selector
  metric: Metric

  /// target specifies the target value for the given metric
  target: Target
}

/// resource refers to a resource metric (such as those specified in requests and limits) known to
/// Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such metrics are
/// built in to Kubernetes, and have special scaling options on top of those available to normal per-pod
/// metrics using the "pods" source.
class Resource {
  /// name is the name of the resource in question.
  name: String

  /// target specifies the target value for the given metric
  target: Target
}

/// ConfigMapReference is a reference to a kubernetes configmap.
class Configmap {
  name: String

  namespace: String
}

/// Environment is the build and runtime environment that this function is associated with. An
/// Environment with this name should exist, otherwise the function cannot be invoked.
class Environment {
  name: String

  namespace: String
}

/// Reference to a package containing deployment and optionally the source.
class Package {
  /// FunctionName specifies a specific function within the package. This allows functions to share
  /// packages, by having different functions within the same package.
  ///
  /// Fission itself does not interpret this path. It is passed verbatim to build and runtime
  /// environments.
  ///
  /// This is optional: if unspecified, the environment has a default name.
  functionName: String?

  /// Package reference
  packageref: Packageref?
}

/// Package reference
class Packageref {
  name: String?

  namespace: String?

  /// Including resource version in the reference forces the function to be updated on package update,
  /// making it possible to cache the function based on its metadata.
  resourceversion: String?
}

/// cpu and memory resources as per K8S standards This is only for newdeploy to set up resource
/// limitation when creating deployment for a function.
class Resources {
  /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this
  /// container.
  ///
  /// This field depends on the DynamicResourceAllocation feature gate.
  ///
  /// This field is immutable. It can only be set for containers.
  claims: Listing<Claim>?

  /// Limits describes the maximum amount of compute resources allowed. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  limits: Mapping<String, Int|String>?

  /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a
  /// container, it defaults to Limits if that is explicitly specified, otherwise to an
  /// implementation-defined value. Requests cannot exceed Limits. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  requests: Mapping<String, Int|String>?
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
class Claim {
  /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is
  /// used. It makes that resource available inside a container.
  name: String

  /// Request is the name chosen for a request in the referenced claim. If empty, everything from the
  /// claim is made available, otherwise only the result of this request.
  request: String?
}

/// SecretReference is a reference to a kubernetes secret.
class Secret {
  name: String

  namespace: String
}
