/// MessageQueueTrigger invokes functions when messages arrive to certain topic that trigger subscribes
/// to.
///
/// This module was generated from the CustomResourceDefinition at
/// <file:///Users/lucsoft/Developer/infra-hmsys-sys/packages/io.Fission/>.
module io.fission.v1.MessageQueueTrigger

extends "@k8s/K8sResource.pkl"

import "@k8s/apimachinery/pkg/apis/meta/v1/ObjectMeta.pkl"

fixed apiVersion: "fission.io/v1"

fixed kind: "MessageQueueTrigger"

/// Standard object's metadata.
///
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>.
metadata: ObjectMeta?

/// MessageQueueTriggerSpec defines a binding from a topic in a message queue to a function.
spec: Spec

/// MessageQueueTriggerSpec defines a binding from a topic in a message queue to a function.
class Spec {
  /// Content type of payload
  contentType: String?

  /// The period to wait after the last trigger reported active before scaling the deployment back to 0
  cooldownPeriod: Int?

  /// Topic to collect error response sent from function
  errorTopic: String?

  /// The reference to a function for message queue trigger to invoke with when receiving messages from
  /// subscribed topic.
  functionref: Functionref?

  /// Maximum number of replicas KEDA will scale the deployment up to
  maxReplicaCount: Int?

  /// Maximum times for message queue trigger to retry
  maxRetries: Int?

  /// Type of message queue (NATS, Kafka, AzureQueue)
  messageQueueType: String?

  /// ScalerTrigger fields
  metadata: Mapping<String, String>?

  /// Minimum number of replicas KEDA will scale the deployment down to
  minReplicaCount: Int?

  /// Kind of Message Queue Trigger to be created, by default its fission
  mqtkind: String?

  /// (Optional) Podspec allows modification of deployed runtime pod with Kubernetes PodSpec The merging
  /// logic is briefly described below and detailed MergePodSpec function - Volumes mounts and env
  /// variables for function and fetcher container are appended - All additional containers and init
  /// containers are appended - Volume definitions are appended - Lists such as tolerations,
  /// ImagePullSecrets, HostAliases are appended - Structs are merged and variables from pod spec take
  /// precedence
  podspec: Podspec?

  /// The period to check each trigger source on every ScaledObject, and scale the deployment up or down
  /// accordingly
  pollingInterval: Int?

  /// Topic for message queue trigger to sent response from function.
  respTopic: String?

  /// Secret name
  secret: String?

  /// Subscribed topic
  topic: String
}

/// The reference to a function for message queue trigger to invoke with when receiving messages from
/// subscribed topic.
class Functionref {
  /// Function Reference by weight. this map contains function name as key and its weight as the value.
  /// This is for canary upgrade purpose.
  functionweights: Mapping<String, Int>?

  /// Name of the function.
  name: String

  /// Type indicates whether this function reference is by name or selector. For now, the only supported
  /// reference type is by "name". Future reference types: * Function by label or annotation * Branch or
  /// tag of a versioned function * A "rolling upgrade" from one version of a function to another
  /// Available value: - name - function-weights
  type: String
}

/// (Optional) Podspec allows modification of deployed runtime pod with Kubernetes PodSpec The merging
/// logic is briefly described below and detailed MergePodSpec function - Volumes mounts and env
/// variables for function and fetcher container are appended - All additional containers and init
/// containers are appended - Volume definitions are appended - Lists such as tolerations,
/// ImagePullSecrets, HostAliases are appended - Structs are merged and variables from pod spec take
/// precedence
class Podspec {
  /// Optional duration in seconds the pod may be active on the node relative to StartTime before the
  /// system will actively try to mark it failed and kill associated containers. Value must be a positive
  /// integer.
  activeDeadlineSeconds: Int?

  /// If specified, the pod's scheduling constraints
  affinity: Affinity?

  /// AutomountServiceAccountToken indicates whether a service account token should be automatically
  /// mounted.
  automountServiceAccountToken: Boolean?

  /// List of containers belonging to the pod. Containers cannot currently be added or removed. There
  /// must be at least one container in a Pod. Cannot be updated.
  containers: Listing<InitContainer>

  /// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated
  /// DNS configuration based on DNSPolicy.
  dnsConfig: DnsConfig?

  /// Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are 'ClusterFirstWithHostNet',
  /// 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the
  /// policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify
  /// DNS policy explicitly to 'ClusterFirstWithHostNet'.
  dnsPolicy: String?

  /// EnableServiceLinks indicates whether information about services should be injected into pod's
  /// environment variables, matching the syntax of Docker links. Optional: Defaults to true.
  enableServiceLinks: Boolean?

  /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to
  /// perform user-initiated actions such as debugging. This list cannot be specified when creating a
  /// pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to
  /// an existing pod, use the pod's ephemeralcontainers subresource.
  ephemeralContainers: Listing<EphemeralContainer>?

  /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if
  /// specified.
  hostAliases: Listing<HostAliase>?

  /// Use the host's ipc namespace. Optional: Default to false.
  hostIPC: Boolean?

  /// Host networking requested for this pod. Use the host's network namespace. When using HostNetwork
  /// you should specify ports so the scheduler is aware. When `hostNetwork` is true, specified
  /// `hostPort` fields in port definitions must match `containerPort`, and unspecified `hostPort` fields
  /// in port definitions are defaulted to match `containerPort`. Default to false.
  hostNetwork: Boolean?

  /// Use the host's pid namespace. Optional: Default to false.
  hostPID: Boolean?

  /// Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod
  /// will be run in the host user namespace, useful for when the pod needs a feature only available to
  /// the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a
  /// new userns is created for the pod. Setting false is useful for mitigating container breakout
  /// vulnerabilities even allowing users to run their containers as root without actually having root
  /// privileges on the host. This field is alpha-level and is only honored by servers that enable the
  /// UserNamespacesSupport feature.
  hostUsers: Boolean?

  /// Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a
  /// system-defined value.
  hostname: String?

  /// HostnameOverride specifies an explicit override for the pod's hostname as perceived by the pod.
  /// This field only specifies the pod's hostname and does not affect its DNS records. When this field
  /// is set to a non-empty string: - It takes precedence over the values set in `hostname` and
  /// `subdomain`. - The Pod's hostname will be set to this value. - `setHostnameAsFQDN` must be nil or
  /// set to false. - `hostNetwork` must be set to false.
  ///
  /// This field must be a valid DNS subdomain as defined in RFC 1123 and contain at most 64 characters.
  /// Requires the HostnameOverride feature gate to be enabled.
  hostnameOverride: String?

  /// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for
  /// pulling any of the images used by this PodSpec. If specified, these secrets will be passed to
  /// individual puller implementations for them to use. More info:
  /// https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  imagePullSecrets: Listing<ImagePullSecret>?

  /// List of initialization containers belonging to the pod. Init containers are executed in order prior
  /// to containers being started. If any init container fails, the pod is considered to have failed and
  /// is handled according to its restartPolicy. The name for an init container or normal container must
  /// be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes,
  /// Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into
  /// account during scheduling by finding the highest request/limit for each resource type, and then
  /// using the max of that value or the sum of the normal containers. Limits are applied to init
  /// containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be
  /// updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  initContainers: Listing<InitContainer>?

  /// NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for
  /// scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this
  /// node becomes responsible for the lifecycle of this pod. This field should not be used to express a
  /// desire for the pod to be scheduled on a specific node.
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
  nodeName: String?

  /// NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must
  /// match a node's labels for the pod to be scheduled on that node. More info:
  /// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  nodeSelector: Mapping<String, String>?

  /// Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this
  /// is set.
  ///
  /// If the OS field is set to linux, the following fields must be unset:
  /// -securityContext.windowsOptions
  ///
  /// If the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC -
  /// spec.hostUsers - spec.resources - spec.securityContext.appArmorProfile -
  /// spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile -
  /// spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy -
  /// spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser -
  /// spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups -
  /// spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile
  /// - spec.containers[*].securityContext.seLinuxOptions -
  /// spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities
  /// - spec.containers[*].securityContext.readOnlyRootFilesystem -
  /// spec.containers[*].securityContext.privileged -
  /// spec.containers[*].securityContext.allowPrivilegeEscalation -
  /// spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser -
  /// spec.containers[*].securityContext.runAsGroup
  os: Os?

  /// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
  /// This field will be autopopulated at admission time by the RuntimeClass admission controller. If the
  /// RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The
  /// RuntimeClass admission controller will reject Pod create requests which have the overhead already
  /// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
  /// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More
  /// info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
  overhead: Mapping<String, Int|String>?

  /// PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never,
  /// PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.
  preemptionPolicy: String?

  /// The priority value. Various system components use this field to find the priority of the pod. When
  /// Priority Admission Controller is enabled, it prevents users from setting this field. The admission
  /// controller populates this field from PriorityClassName. The higher the value, the higher the
  /// priority.
  priority: Int?

  /// If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical"
  /// are two special keywords which indicate the highest priorities with the former being the highest
  /// priority. Any other name must be defined by creating a PriorityClass object with that name. If not
  /// specified, the pod priority will be default or zero if there is no default.
  priorityClassName: String?

  /// If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its
  /// containers are ready AND all conditions specified in the readiness gates have status equal to
  /// "True" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
  readinessGates: Listing<ReadinessGate>?

  /// ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is
  /// allowed to start. The resources will be made available to those containers which consume them by
  /// name.
  ///
  /// This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
  ///
  /// This field is immutable.
  resourceClaims: Listing<ResourceClaim>?

  /// Resources is the total amount of CPU and Memory resources required by all containers in the pod. It
  /// supports specifying Requests and Limits for "cpu", "memory" and "hugepages-" resource names only.
  /// ResourceClaims are not supported.
  ///
  /// This field enables fine-grained control over resource allocation for the entire pod, allowing
  /// resource sharing among containers in a pod.
  ///
  /// This is an alpha field and requires enabling the PodLevelResources feature gate.
  resources: Resources?

  /// Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some
  /// contexts, only a subset of those values may be permitted. Default to Always. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
  restartPolicy: String?

  /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to
  /// run this pod. If no RuntimeClass resource matches the named class, the pod will not be run. If
  /// unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an empty
  /// definition that uses the default runtime handler. More info:
  /// https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
  runtimeClassName: String?

  /// If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be
  /// dispatched by default scheduler.
  schedulerName: String?

  /// SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If
  /// schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will
  /// not attempt to schedule the pod.
  ///
  /// SchedulingGates can only be set at pod creation time, and be removed only afterwards.
  schedulingGates: Listing<SchedulingGate>?

  /// SecurityContext holds pod-level security attributes and common container settings. Optional:
  /// Defaults to empty. See type description for default values of each field.
  securityContext: SecurityContext?

  /// DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use
  /// serviceAccountName instead.
  serviceAccount: String?

  /// ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info:
  /// https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccountName: String?

  /// If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the
  /// default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the
  /// nodename field of struct utsname). In Windows containers, this means setting the registry value of
  /// hostname for the registry key
  /// HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does
  /// not have FQDN, this has no effect. Default to false.
  setHostnameAsFQDN: Boolean?

  /// Share a single process namespace between all of the containers in a pod. When this is set
  /// containers will be able to view and signal processes from other containers in the same pod, and the
  /// first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace
  /// cannot both be set. Optional: Default to false.
  shareProcessNamespace: Boolean?

  /// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod
  /// namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
  subdomain: String?

  /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete
  /// request. Value must be non-negative integer. The value zero indicates stop immediately via the kill
  /// signal (no opportunity to shut down). If this value is nil, the default grace period will be used
  /// instead. The grace period is the duration in seconds after the processes running in the pod are
  /// sent a termination signal and the time when the processes are forcibly halted with a kill signal.
  /// Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
  terminationGracePeriodSeconds: Int?

  /// If specified, the pod's tolerations.
  tolerations: Listing<Toleration>?

  /// TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
  /// Scheduler will schedule pods in a way which abides by the constraints. All
  /// topologySpreadConstraints are ANDed.
  topologySpreadConstraints: Listing<TopologySpreadConstraint>?

  /// List of volumes that can be mounted by containers belonging to the pod. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes
  volumes: Listing<Volume>?
}

/// If specified, the pod's scheduling constraints
class Affinity {
  /// Describes node affinity scheduling rules for the pod.
  nodeAffinity: NodeAffinity?

  /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as
  /// some other pod(s)).
  podAffinity: PodAffinity?

  /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone,
  /// etc. as some other pod(s)).
  podAntiAffinity: PodAntiAffinity?
}

/// Describes node affinity scheduling rules for the pod.
class NodeAffinity {
  /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified
  /// by this field, but it may choose a node that violates one or more of the expressions. The node that
  /// is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of
  /// the scheduling requirements (resource request, requiredDuringScheduling affinity expressions,
  /// etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum
  /// if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the
  /// most preferred.
  preferredDuringSchedulingIgnoredDuringExecution: Listing<PreferredDuringSchedulingIgnoredDuringExecution>?

  /// If the affinity requirements specified by this field are not met at scheduling time, the pod will
  /// not be scheduled onto the node. If the affinity requirements specified by this field cease to be
  /// met at some point during pod execution (e.g. due to an update), the system may or may not try to
  /// eventually evict the pod from its node.
  requiredDuringSchedulingIgnoredDuringExecution: RequiredDuringSchedulingIgnoredDuringExecution?
}

/// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A
/// null preferred scheduling term matches no objects (i.e. is also a no-op).
class PreferredDuringSchedulingIgnoredDuringExecution {
  /// A node selector term, associated with the corresponding weight.
  preference: Preference

  /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  weight: Int
}

/// A node selector term, associated with the corresponding weight.
class Preference {
  /// A list of node selector requirements by node's labels.
  matchExpressions: Listing<MatchField>?

  /// A list of node selector requirements by node's fields.
  matchFields: Listing<MatchField>?
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates
/// the key and values.
class MatchField {
  /// The label key that the selector applies to.
  key: String

  /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists,
  /// DoesNotExist. Gt, and Lt.
  operator: String

  /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If
  /// the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or
  /// Lt, the values array must have a single element, which will be interpreted as an integer. This
  /// array is replaced during a strategic merge patch.
  values: Listing<String>?
}

/// If the affinity requirements specified by this field are not met at scheduling time, the pod will not
/// be scheduled onto the node. If the affinity requirements specified by this field cease to be met at
/// some point during pod execution (e.g. due to an update), the system may or may not try to eventually
/// evict the pod from its node.
class RequiredDuringSchedulingIgnoredDuringExecution {
  /// Required. A list of node selector terms. The terms are ORed.
  nodeSelectorTerms: Listing<NodeSelectorTerm>
}

/// A null or empty node selector term matches no objects. The requirements of them are ANDed. The
/// TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
class NodeSelectorTerm {
  /// A list of node selector requirements by node's labels.
  matchExpressions: Listing<MatchField>?

  /// A list of node selector requirements by node's fields.
  matchFields: Listing<MatchField>?
}

/// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some
/// other pod(s)).
class PodAffinity {
  /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified
  /// by this field, but it may choose a node that violates one or more of the expressions. The node that
  /// is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of
  /// the scheduling requirements (resource request, requiredDuringScheduling affinity expressions,
  /// etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum
  /// if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
  /// sum are the most preferred.
  preferredDuringSchedulingIgnoredDuringExecution: Listing<PreferredDuringSchedulingIgnoredDuringExecution>?

  /// If the affinity requirements specified by this field are not met at scheduling time, the pod will
  /// not be scheduled onto the node. If the affinity requirements specified by this field cease to be
  /// met at some point during pod execution (e.g. due to a pod label update), the system may or may not
  /// try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes
  /// corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  requiredDuringSchedulingIgnoredDuringExecution: Listing<RequiredDuringSchedulingIgnoredDuringExecution>?
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most
/// preferred node(s)
class PreferredDuringSchedulingIgnoredDuringExecution {
  /// Required. A pod affinity term, associated with the corresponding weight.
  podAffinityTerm: PodAffinityTerm

  /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  weight: Int
}

/// Required. A pod affinity term, associated with the corresponding weight.
class PodAffinityTerm {
  /// A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm
  /// matches with no Pods.
  labelSelector: LabelSelector?

  /// MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `labelSelector` as `key in (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector
  /// isn't set.
  matchLabelKeys: Listing<String>?

  /// MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `labelSelector` as `key notin (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when
  /// labelSelector isn't set.
  mismatchLabelKeys: Listing<String>?

  /// A label query over the set of namespaces that the term applies to. The term is applied to the union
  /// of the namespaces selected by this field and the ones listed in the namespaces field. null selector
  /// and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all
  /// namespaces.
  namespaceSelector: NamespaceSelector?

  /// namespaces specifies a static list of namespace names that the term applies to. The term is applied
  /// to the union of the namespaces listed in this field and the ones selected by namespaceSelector.
  /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
  namespaces: Listing<String>?

  /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
  /// whose value of the label with key topologyKey matches that of any node on which any of the selected
  /// pods is running. Empty topologyKey is not allowed.
  topologyKey: String
}

/// A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches
/// with no Pods.
class LabelSelector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates
/// the key and values.
class MatchExpression {
  /// key is the label key that the selector applies to.
  key: String

  /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists
  /// and DoesNotExist.
  operator: String

  /// values is an array of string values. If the operator is In or NotIn, the values array must be
  /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is
  /// replaced during a strategic merge patch.
  values: Listing<String>?
}

/// A label query over the set of namespaces that the term applies to. The term is applied to the union
/// of the namespaces selected by this field and the ones listed in the namespaces field. null selector
/// and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all
/// namespaces.
class NamespaceSelector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s))
/// that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where
/// co-located is defined as running on a node whose value of the label with key <topologyKey> matches
/// that of any node on which a pod of the set of pods is running
class RequiredDuringSchedulingIgnoredDuringExecution {
  /// A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm
  /// matches with no Pods.
  labelSelector: LabelSelector?

  /// MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `labelSelector` as `key in (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector
  /// isn't set.
  matchLabelKeys: Listing<String>?

  /// MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `labelSelector` as `key notin (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when
  /// labelSelector isn't set.
  mismatchLabelKeys: Listing<String>?

  /// A label query over the set of namespaces that the term applies to. The term is applied to the union
  /// of the namespaces selected by this field and the ones listed in the namespaces field. null selector
  /// and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all
  /// namespaces.
  namespaceSelector: NamespaceSelector?

  /// namespaces specifies a static list of namespace names that the term applies to. The term is applied
  /// to the union of the namespaces listed in this field and the ones selected by namespaceSelector.
  /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
  namespaces: Listing<String>?

  /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
  /// whose value of the label with key topologyKey matches that of any node on which any of the selected
  /// pods is running. Empty topologyKey is not allowed.
  topologyKey: String
}

/// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone,
/// etc. as some other pod(s)).
class PodAntiAffinity {
  /// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions
  /// specified by this field, but it may choose a node that violates one or more of the expressions. The
  /// node that is most preferred is the one with the greatest sum of weights, i.e. for each node that
  /// meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity
  /// expressions, etc.), compute a sum by iterating through the elements of this field and subtracting
  /// "weight" from the sum if the node has pods which matches the corresponding podAffinityTerm; the
  /// node(s) with the highest sum are the most preferred.
  preferredDuringSchedulingIgnoredDuringExecution: Listing<PreferredDuringSchedulingIgnoredDuringExecution>?

  /// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod
  /// will not be scheduled onto the node. If the anti-affinity requirements specified by this field
  /// cease to be met at some point during pod execution (e.g. due to a pod label update), the system may
  /// or may not try to eventually evict the pod from its node. When there are multiple elements, the
  /// lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be
  /// satisfied.
  requiredDuringSchedulingIgnoredDuringExecution: Listing<RequiredDuringSchedulingIgnoredDuringExecution>?
}

/// A single application container that you want to run within a pod.
class InitContainer {
  /// Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable
  /// references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be
  /// resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $,
  /// which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string
  /// literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the
  /// variable exists or not. Cannot be updated. More info:
  /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  args: Listing<String>?

  /// Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is
  /// not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a
  /// variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are
  /// reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of
  /// whether the variable exists or not. Cannot be updated. More info:
  /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  command: Listing<String>?

  /// List of environment variables to set in the container. Cannot be updated.
  env: Listing<Env>?

  /// List of sources to populate environment variables in the container. The keys defined within a
  /// source may consist of any printable ASCII characters except '='. When a key exists in multiple
  /// sources, the value associated with the last source will take precedence. Values defined by an Env
  /// with a duplicate key will take precedence. Cannot be updated.
  envFrom: Listing<EnvFrom>?

  /// Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field
  /// is optional to allow higher level config management to default or override container images in
  /// workload controllers like Deployments and StatefulSets.
  image: String?

  /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is
  /// specified, or IfNotPresent otherwise. Cannot be updated. More info:
  /// https://kubernetes.io/docs/concepts/containers/images#updating-images
  imagePullPolicy: String?

  /// Actions that the management system should take in response to container lifecycle events. Cannot be
  /// updated.
  lifecycle: Lifecycle?

  /// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be
  /// updated. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  livenessProbe: LivenessProbe?

  /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name
  /// (DNS_LABEL). Cannot be updated.
  name: String

  /// List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port
  /// from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container
  /// will be accessible from the network. Modifying this array with strategic merge patch may corrupt
  /// the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot
  /// be updated.
  ports: Listing<Port>?

  /// Periodic probe of container service readiness. Container will be removed from service endpoints if
  /// the probe fails. Cannot be updated. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  readinessProbe: ReadinessProbe?

  /// Resources resize policy for the container.
  resizePolicy: Listing<ResizePolicy>?

  /// Compute Resources required by this container. Cannot be updated. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: Resources?

  /// RestartPolicy defines the restart behavior of individual containers in a pod. This overrides the
  /// pod-level restart policy. When this field is not specified, the restart behavior is defined by the
  /// Pod's restart policy and the container type. Additionally, setting the RestartPolicy as "Always"
  /// for the init container will have the following effect: this init container will be continually
  /// restarted on exit until all regular containers have terminated. Once all regular containers have
  /// completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle
  /// differs from normal init containers and is often referred to as a "sidecar" container. Although
  /// this init container still starts in the init container sequence, it does not wait for the container
  /// to complete before proceeding to the next init container. Instead, the next init container starts
  /// immediately after this init container is started, or after any startupProbe has successfully
  /// completed.
  restartPolicy: String?

  /// Represents a list of rules to be checked to determine if the container should be restarted on exit.
  /// The rules are evaluated in order. Once a rule matches a container exit condition, the remaining
  /// rules are ignored. If no rule matches the container exit condition, the Container-level restart
  /// policy determines the whether the container is restarted or not. Constraints on the rules: - At
  /// most 20 rules are allowed. - Rules can have the same action. - Identical rules are not forbidden in
  /// validations. When rules are specified, container MUST set RestartPolicy explicitly even it if
  /// matches the Pod's RestartPolicy.
  restartPolicyRules: Listing<RestartPolicyRule>?

  /// SecurityContext defines the security options the container should be run with. If set, the fields
  /// of SecurityContext override the equivalent fields of PodSecurityContext. More info:
  /// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext: SecurityContext?

  /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are
  /// executed until this completes successfully. If this probe fails, the Pod will be restarted, just as
  /// if the livenessProbe failed. This can be used to provide different probe parameters at the
  /// beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than
  /// during steady-state operation. This cannot be updated. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  startupProbe: StartupProbe?

  /// Whether this container should allocate a buffer for stdin in the container runtime. If this is not
  /// set, reads from stdin in the container will always result in EOF. Default is false.
  stdin: Boolean?

  /// Whether the container runtime should close the stdin channel after it has been opened by a single
  /// attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If
  /// stdinOnce is set to true, stdin is opened on container start, is empty until the first client
  /// attaches to stdin, and then remains open and accepts data until the client disconnects, at which
  /// time stdin is closed and remains closed until the container is restarted. If this flag is false, a
  /// container processes that reads from stdin will never receive an EOF. Default is false
  stdinOnce: Boolean?

  /// Optional: Path at which the file to which the container's termination message will be written is
  /// mounted into the container's filesystem. Message written is intended to be brief final status, such
  /// as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The
  /// total message length across all containers will be limited to 12kb. Defaults to
  /// /dev/termination-log. Cannot be updated.
  terminationMessagePath: String?

  /// Indicate how the termination message should be populated. File will use the contents of
  /// terminationMessagePath to populate the container status message on both success and failure.
  /// FallbackToLogsOnError will use the last chunk of container log output if the termination message
  /// file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80
  /// lines, whichever is smaller. Defaults to File. Cannot be updated.
  terminationMessagePolicy: String?

  /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default
  /// is false.
  tty: Boolean?

  /// volumeDevices is the list of block devices to be used by the container.
  volumeDevices: Listing<VolumeDevice>?

  /// Pod volumes to mount into the container's filesystem. Cannot be updated.
  volumeMounts: Listing<VolumeMount>?

  /// Container's working directory. If not specified, the container runtime's default will be used,
  /// which might be configured in the container image. Cannot be updated.
  workingDir: String?
}

/// EnvVar represents an environment variable present in a Container.
class Env {
  /// Name of the environment variable. May consist of any printable ASCII characters except '='.
  name: String

  /// Variable references $(VAR_NAME) are expanded using the previously defined environment variables in
  /// the container and any service environment variables. If a variable cannot be resolved, the
  /// reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows
  /// for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal
  /// "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists
  /// or not. Defaults to "".
  value: String?

  /// Source for the environment variable's value. Cannot be used if value is not empty.
  valueFrom: ValueFrom?
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
class ValueFrom {
  /// Selects a key of a ConfigMap.
  configMapKeyRef: ConfigMapKeyRef?

  /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`,
  /// `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP,
  /// status.podIP, status.podIPs.
  fieldRef: FieldRef?

  /// FileKeyRef selects a key of the env file. Requires the EnvFiles feature gate to be enabled.
  fileKeyRef: FileKeyRef?

  /// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory,
  /// limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are
  /// currently supported.
  resourceFieldRef: ResourceFieldRef?

  /// Selects a key of a secret in the pod's namespace
  secretKeyRef: SecretKeyRef?
}

/// Selects a key of a ConfigMap.
class ConfigMapKeyRef {
  /// The key to select.
  key: String

  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?

  /// Specify whether the ConfigMap or its key must be defined
  optional: Boolean?
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`,
/// `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP,
/// status.podIPs.
class FieldRef {
  /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
  apiVersion: String?

  /// Path of the field to select in the specified API version.
  fieldPath: String
}

/// FileKeyRef selects a key of the env file. Requires the EnvFiles feature gate to be enabled.
class FileKeyRef {
  /// The key within the env file. An invalid key will prevent the pod from starting. The keys defined
  /// within a source may consist of any printable ASCII characters except '='. During Alpha stage of the
  /// EnvFiles feature gate, the key size is limited to 128 characters.
  key: String

  /// Specify whether the file or its key must be defined. If the file or key does not exist, then the
  /// env var is not published. If optional is set to true and the specified key does not exist, the
  /// environment variable will not be set in the Pod's containers.
  ///
  /// If optional is set to false and the specified key does not exist, an error will be returned during
  /// Pod creation.
  optional: Boolean?

  /// The path within the volume from which to select the file. Must be relative and may not contain the
  /// '..' path or start with '..'.
  path: String

  /// The name of the volume mount containing the env file.
  volumeName: String
}

/// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory,
/// limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently
/// supported.
class ResourceFieldRef {
  /// Container name: required for volumes, optional for env vars
  containerName: String?

  /// Specifies the output format of the exposed resources, defaults to "1"
  divisor: (Int|String)?

  /// Required: resource to select
  resource: String
}

/// Selects a key of a secret in the pod's namespace
class SecretKeyRef {
  /// The key of the secret to select from. Must be a valid secret key.
  key: String

  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?

  /// Specify whether the Secret or its key must be defined
  optional: Boolean?
}

/// EnvFromSource represents the source of a set of ConfigMaps or Secrets
class EnvFrom {
  /// The ConfigMap to select from
  configMapRef: ConfigMapRef?

  /// Optional text to prepend to the name of each environment variable. May consist of any printable
  /// ASCII characters except '='.
  prefix: String?

  /// The Secret to select from
  secretRef: SecretRef?
}

/// The ConfigMap to select from
class ConfigMapRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?

  /// Specify whether the ConfigMap must be defined
  optional: Boolean?
}

/// The Secret to select from
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?

  /// Specify whether the Secret must be defined
  optional: Boolean?
}

/// Actions that the management system should take in response to container lifecycle events. Cannot be
/// updated.
class Lifecycle {
  /// PostStart is called immediately after a container is created. If the handler fails, the container
  /// is terminated and restarted according to its restart policy. Other management of the container
  /// blocks until the hook completes. More info:
  /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  postStart: PostStart?

  /// PreStop is called immediately before a container is terminated due to an API request or management
  /// event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is
  /// not called if the container crashes or exits. The Pod's termination grace period countdown begins
  /// before the PreStop hook is executed. Regardless of the outcome of the handler, the container will
  /// eventually terminate within the Pod's termination grace period (unless delayed by finalizers).
  /// Other management of the container blocks until the hook completes or until the termination grace
  /// period is reached. More info:
  /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  preStop: PreStop?

  /// StopSignal defines which signal will be sent to a container when it is being stopped. If not
  /// specified, the default is defined by the container runtime in use. StopSignal can only be set for
  /// Pods with a non-empty .spec.os.name
  stopSignal: String?
}

/// PostStart is called immediately after a container is created. If the handler fails, the container is
/// terminated and restarted according to its restart policy. Other management of the container blocks
/// until the hook completes. More info:
/// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
class PostStart {
  /// Exec specifies a command to execute in the container.
  exec: Exec?

  /// HTTPGet specifies an HTTP GET request to perform.
  httpGet: HttpGet?

  /// Sleep represents a duration that the container should sleep.
  sleep: Sleep?

  /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for backward compatibility.
  /// There is no validation of this field and lifecycle hooks will fail at runtime when it is specified.
  tcpSocket: TcpSocket?
}

/// Exec specifies a command to execute in the container.
class Exec {
  /// Command is the command line to execute inside the container, the working directory for the command
  /// is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a
  /// shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to
  /// explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is
  /// unhealthy.
  command: Listing<String>?
}

/// HTTPGet specifies an HTTP GET request to perform.
class HttpGet {
  /// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders
  /// instead.
  host: String?

  /// Custom headers to set in the request. HTTP allows repeated headers.
  httpHeaders: Listing<HttpHeader>?

  /// Path to access on the HTTP server.
  path: String?

  /// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name
  /// must be an IANA_SVC_NAME.
  port: Int|String

  /// Scheme to use for connecting to the host. Defaults to HTTP.
  scheme: String?
}

/// HTTPHeader describes a custom header to be used in HTTP probes
class HttpHeader {
  /// The header field name. This will be canonicalized upon output, so case-variant names will be
  /// understood as the same header.
  name: String

  /// The header field value
  value: String
}

/// Sleep represents a duration that the container should sleep.
class Sleep {
  /// Seconds is the number of seconds to sleep.
  seconds: Int
}

/// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for backward compatibility.
/// There is no validation of this field and lifecycle hooks will fail at runtime when it is specified.
class TcpSocket {
  /// Optional: Host name to connect to, defaults to the pod IP.
  host: String?

  /// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name
  /// must be an IANA_SVC_NAME.
  port: Int|String
}

/// PreStop is called immediately before a container is terminated due to an API request or management
/// event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is
/// not called if the container crashes or exits. The Pod's termination grace period countdown begins
/// before the PreStop hook is executed. Regardless of the outcome of the handler, the container will
/// eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other
/// management of the container blocks until the hook completes or until the termination grace period is
/// reached. More info:
/// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
class PreStop {
  /// Exec specifies a command to execute in the container.
  exec: Exec?

  /// HTTPGet specifies an HTTP GET request to perform.
  httpGet: HttpGet?

  /// Sleep represents a duration that the container should sleep.
  sleep: Sleep?

  /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for backward compatibility.
  /// There is no validation of this field and lifecycle hooks will fail at runtime when it is specified.
  tcpSocket: TcpSocket?
}

/// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be
/// updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
class LivenessProbe {
  /// Exec specifies a command to execute in the container.
  exec: Exec?

  /// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults
  /// to 3. Minimum value is 1.
  failureThreshold: Int?

  /// GRPC specifies a GRPC HealthCheckRequest.
  grpc: Grpc?

  /// HTTPGet specifies an HTTP GET request to perform.
  httpGet: HttpGet?

  /// Number of seconds after the container has started before liveness probes are initiated. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  initialDelaySeconds: Int?

  /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  periodSeconds: Int?

  /// Minimum consecutive successes for the probe to be considered successful after having failed.
  /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  successThreshold: Int?

  /// TCPSocket specifies a connection to a TCP port.
  tcpSocket: TcpSocket?

  /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace
  /// period is the duration in seconds after the processes running in the pod are sent a termination
  /// signal and the time when the processes are forcibly halted with a kill signal. Set this value
  /// longer than the expected cleanup time for your process. If this value is nil, the pod's
  /// terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by
  /// the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the
  /// kill signal (no opportunity to shut down). This is a beta field and requires enabling
  /// ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is
  /// used if unset.
  terminationGracePeriodSeconds: Int?

  /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More
  /// info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  timeoutSeconds: Int?
}

/// GRPC specifies a GRPC HealthCheckRequest.
class Grpc {
  /// Port number of the gRPC service. Number must be in the range 1 to 65535.
  port: Int

  /// Service is the name of the service to place in the gRPC HealthCheckRequest (see
  /// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
  ///
  /// If this is not specified, the default behavior is defined by gRPC.
  service: String?
}

/// TCPSocket specifies a connection to a TCP port.
class TcpSocket {
  /// Optional: Host name to connect to, defaults to the pod IP.
  host: String?

  /// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name
  /// must be an IANA_SVC_NAME.
  port: Int|String
}

/// ContainerPort represents a network port in a single container.
class Port {
  /// Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
  containerPort: Int

  /// What host IP to bind the external port to.
  hostIP: String?

  /// Number of port to expose on the host. If specified, this must be a valid port number, 0 < x <
  /// 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need
  /// this.
  hostPort: Int?

  /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod
  /// must have a unique name. Name for the port that can be referred to by services.
  name: String?

  /// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
  protocol: String?
}

/// Periodic probe of container service readiness. Container will be removed from service endpoints if
/// the probe fails. Cannot be updated. More info:
/// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
class ReadinessProbe {
  /// Exec specifies a command to execute in the container.
  exec: Exec?

  /// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults
  /// to 3. Minimum value is 1.
  failureThreshold: Int?

  /// GRPC specifies a GRPC HealthCheckRequest.
  grpc: Grpc?

  /// HTTPGet specifies an HTTP GET request to perform.
  httpGet: HttpGet?

  /// Number of seconds after the container has started before liveness probes are initiated. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  initialDelaySeconds: Int?

  /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  periodSeconds: Int?

  /// Minimum consecutive successes for the probe to be considered successful after having failed.
  /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  successThreshold: Int?

  /// TCPSocket specifies a connection to a TCP port.
  tcpSocket: TcpSocket?

  /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace
  /// period is the duration in seconds after the processes running in the pod are sent a termination
  /// signal and the time when the processes are forcibly halted with a kill signal. Set this value
  /// longer than the expected cleanup time for your process. If this value is nil, the pod's
  /// terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by
  /// the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the
  /// kill signal (no opportunity to shut down). This is a beta field and requires enabling
  /// ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is
  /// used if unset.
  terminationGracePeriodSeconds: Int?

  /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More
  /// info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  timeoutSeconds: Int?
}

/// ContainerResizePolicy represents resource resize policy for the container.
class ResizePolicy {
  /// Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
  resourceName: String

  /// Restart policy to apply when specified resource is resized. If not specified, it defaults to
  /// NotRequired.
  restartPolicy: String
}

/// Compute Resources required by this container. Cannot be updated. More info:
/// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
class Resources {
  /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this
  /// container.
  ///
  /// This field depends on the DynamicResourceAllocation feature gate.
  ///
  /// This field is immutable. It can only be set for containers.
  claims: Listing<Claim>?

  /// Limits describes the maximum amount of compute resources allowed. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  limits: Mapping<String, Int|String>?

  /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a
  /// container, it defaults to Limits if that is explicitly specified, otherwise to an
  /// implementation-defined value. Requests cannot exceed Limits. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  requests: Mapping<String, Int|String>?
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
class Claim {
  /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is
  /// used. It makes that resource available inside a container.
  name: String

  /// Request is the name chosen for a request in the referenced claim. If empty, everything from the
  /// claim is made available, otherwise only the result of this request.
  request: String?
}

/// ContainerRestartRule describes how a container exit is handled.
class RestartPolicyRule {
  /// Specifies the action taken on a container exit if the requirements are satisfied. The only possible
  /// value is "Restart" to restart the container.
  action: String

  /// Represents the exit codes to check on container exits.
  exitCodes: ExitCodes?
}

/// Represents the exit codes to check on container exits.
class ExitCodes {
  /// Represents the relationship between the container exit code(s) and the specified values. Possible
  /// values are: - In: the requirement is satisfied if the container exit code is in the set of
  /// specified values. - NotIn: the requirement is satisfied if the container exit code is not in the
  /// set of specified values.
  operator: String

  /// Specifies the set of values to check for container exit codes. At most 255 elements are allowed.
  values: Listing<Int>?
}

/// SecurityContext defines the security options the container should be run with. If set, the fields of
/// SecurityContext override the equivalent fields of PodSecurityContext. More info:
/// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
class SecurityContext {
  /// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent
  /// process. This bool directly controls if the no_new_privs flag will be set on the container process.
  /// AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has
  /// CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
  allowPrivilegeEscalation: Boolean?

  /// appArmorProfile is the AppArmor options to use by this container. If set, this profile overrides
  /// the pod's appArmorProfile. Note that this field cannot be set when spec.os.name is windows.
  appArmorProfile: AppArmorProfile?

  /// The capabilities to add/drop when running containers. Defaults to the default set of capabilities
  /// granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
  capabilities: Capabilities?

  /// Run container in privileged mode. Processes in privileged containers are essentially equivalent to
  /// root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is
  /// windows.
  privileged: Boolean?

  /// procMount denotes the type of proc mount to use for the containers. The default value is Default
  /// which uses the container runtime defaults for readonly paths and masked paths. This requires the
  /// ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is
  /// windows.
  procMount: String?

  /// Whether this container has a read-only root filesystem. Default is false. Note that this field
  /// cannot be set when spec.os.name is windows.
  readOnlyRootFilesystem: Boolean?

  /// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be
  /// set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value
  /// specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name
  /// is windows.
  runAsGroup: Int?

  /// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the
  /// image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if
  /// it does. If unset or false, no such validation will be performed. May also be set in
  /// PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in
  /// SecurityContext takes precedence.
  runAsNonRoot: Boolean?

  /// The UID to run the entrypoint of the container process. Defaults to user specified in image
  /// metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field
  /// cannot be set when spec.os.name is windows.
  runAsUser: Int?

  /// The SELinux context to be applied to the container. If unspecified, the container runtime will
  /// allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set
  /// in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
  /// precedence. Note that this field cannot be set when spec.os.name is windows.
  seLinuxOptions: SeLinuxOptions?

  /// The seccomp options to use by this container. If seccomp options are provided at both the pod &
  /// container level, the container options override the pod options. Note that this field cannot be set
  /// when spec.os.name is windows.
  seccompProfile: SeccompProfile?

  /// The Windows specific settings applied to all containers. If unspecified, the options from the
  /// PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value
  /// specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name
  /// is linux.
  windowsOptions: WindowsOptions?
}

/// appArmorProfile is the AppArmor options to use by this container. If set, this profile overrides the
/// pod's appArmorProfile. Note that this field cannot be set when spec.os.name is windows.
class AppArmorProfile {
  /// localhostProfile indicates a profile loaded on the node that should be used. The profile must be
  /// preconfigured on the node to work. Must match the loaded name of the profile. Must be set if and
  /// only if type is "Localhost".
  localhostProfile: String?

  /// type indicates which kind of AppArmor profile will be applied. Valid options are: Localhost - a
  /// profile pre-loaded on the node. RuntimeDefault - the container runtime's default profile.
  /// Unconfined - no AppArmor enforcement.
  type: String
}

/// The capabilities to add/drop when running containers. Defaults to the default set of capabilities
/// granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
class Capabilities {
  /// Added capabilities
  add: Listing<String>?

  /// Removed capabilities
  drop: Listing<String>?
}

/// The SELinux context to be applied to the container. If unspecified, the container runtime will
/// allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set
/// in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
/// precedence. Note that this field cannot be set when spec.os.name is windows.
class SeLinuxOptions {
  /// Level is SELinux level label that applies to the container.
  level: String?

  /// Role is a SELinux role label that applies to the container.
  role: String?

  /// Type is a SELinux type label that applies to the container.
  type: String?

  /// User is a SELinux user label that applies to the container.
  user: String?
}

/// The seccomp options to use by this container. If seccomp options are provided at both the pod &
/// container level, the container options override the pod options. Note that this field cannot be set
/// when spec.os.name is windows.
class SeccompProfile {
  /// localhostProfile indicates a profile defined in a file on the node should be used. The profile must
  /// be preconfigured on the node to work. Must be a descending path, relative to the kubelet's
  /// configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any
  /// other type.
  localhostProfile: String?

  /// type indicates which kind of seccomp profile will be applied. Valid options are:
  ///
  /// Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container
  /// runtime default profile should be used. Unconfined - no profile should be applied.
  type: String
}

/// The Windows specific settings applied to all containers. If unspecified, the options from the
/// PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value
/// specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name
/// is linux.
class WindowsOptions {
  /// GMSACredentialSpec is where the GMSA admission webhook
  /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec
  /// named by the GMSACredentialSpecName field.
  gmsaCredentialSpec: String?

  /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
  gmsaCredentialSpecName: String?

  /// HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's
  /// containers must have the same effective HostProcess value (it is not allowed to have a mix of
  /// HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then
  /// HostNetwork must also be set to true.
  hostProcess: Boolean?

  /// The UserName in Windows to run the entrypoint of the container process. Defaults to the user
  /// specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both
  /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  runAsUserName: String?
}

/// StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are
/// executed until this completes successfully. If this probe fails, the Pod will be restarted, just as
/// if the livenessProbe failed. This can be used to provide different probe parameters at the beginning
/// of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during
/// steady-state operation. This cannot be updated. More info:
/// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
class StartupProbe {
  /// Exec specifies a command to execute in the container.
  exec: Exec?

  /// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults
  /// to 3. Minimum value is 1.
  failureThreshold: Int?

  /// GRPC specifies a GRPC HealthCheckRequest.
  grpc: Grpc?

  /// HTTPGet specifies an HTTP GET request to perform.
  httpGet: HttpGet?

  /// Number of seconds after the container has started before liveness probes are initiated. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  initialDelaySeconds: Int?

  /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  periodSeconds: Int?

  /// Minimum consecutive successes for the probe to be considered successful after having failed.
  /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  successThreshold: Int?

  /// TCPSocket specifies a connection to a TCP port.
  tcpSocket: TcpSocket?

  /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace
  /// period is the duration in seconds after the processes running in the pod are sent a termination
  /// signal and the time when the processes are forcibly halted with a kill signal. Set this value
  /// longer than the expected cleanup time for your process. If this value is nil, the pod's
  /// terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by
  /// the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the
  /// kill signal (no opportunity to shut down). This is a beta field and requires enabling
  /// ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is
  /// used if unset.
  terminationGracePeriodSeconds: Int?

  /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More
  /// info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  timeoutSeconds: Int?
}

/// volumeDevice describes a mapping of a raw block device within a container.
class VolumeDevice {
  /// devicePath is the path inside of the container that the device will be mapped to.
  devicePath: String

  /// name must match the name of a persistentVolumeClaim in the pod
  name: String
}

/// VolumeMount describes a mounting of a Volume within a container.
class VolumeMount {
  /// Path within the container at which the volume should be mounted. Must not contain ':'.
  mountPath: String

  /// mountPropagation determines how mounts are propagated from the host to container and the other way
  /// around. When not set, MountPropagationNone is used. This field is beta in 1.10. When
  /// RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
  /// (which defaults to None).
  mountPropagation: String?

  /// This must match the Name of a Volume.
  name: String

  /// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
  readOnly: Boolean?

  /// RecursiveReadOnly specifies whether read-only mounts should be handled recursively.
  ///
  /// If ReadOnly is false, this field has no meaning and must be unspecified.
  ///
  /// If ReadOnly is true, and this field is set to Disabled, the mount is not made recursively
  /// read-only. If this field is set to IfPossible, the mount is made recursively read-only, if it is
  /// supported by the container runtime. If this field is set to Enabled, the mount is made recursively
  /// read-only if it is supported by the container runtime, otherwise the pod will not be started and an
  /// error will be generated to indicate the reason.
  ///
  /// If this field is set to IfPossible or Enabled, MountPropagation must be set to None (or be
  /// unspecified, which defaults to None).
  ///
  /// If this field is not specified, it is treated as an equivalent of Disabled.
  recursiveReadOnly: String?

  /// Path within the volume from which the container's volume should be mounted. Defaults to ""
  /// (volume's root).
  subPath: String?

  /// Expanded path within the volume from which the container's volume should be mounted. Behaves
  /// similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the
  /// container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually
  /// exclusive.
  subPathExpr: String?
}

/// Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS
/// configuration based on DNSPolicy.
class DnsConfig {
  /// A list of DNS name server IP addresses. This will be appended to the base nameservers generated
  /// from DNSPolicy. Duplicated nameservers will be removed.
  nameservers: Listing<String>?

  /// A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy.
  /// Duplicated entries will be removed. Resolution options given in Options will override those that
  /// appear in the base DNSPolicy.
  options: Listing<Option>?

  /// A list of DNS search domains for host-name lookup. This will be appended to the base search paths
  /// generated from DNSPolicy. Duplicated search paths will be removed.
  searches: Listing<String>?
}

/// PodDNSConfigOption defines DNS resolver options of a pod.
class Option {
  /// Name is this DNS resolver option's name. Required.
  name: String?

  /// Value is this DNS resolver option's value.
  value: String?
}

/// An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated
/// activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and
/// they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may
/// evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.
///
/// To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral
/// containers may not be removed or restarted.
class EphemeralContainer {
  /// Arguments to the entrypoint. The image's CMD is used if this is not provided. Variable references
  /// $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the
  /// reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows
  /// for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal
  /// "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists
  /// or not. Cannot be updated. More info:
  /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  args: Listing<String>?

  /// Entrypoint array. Not executed within a shell. The image's ENTRYPOINT is used if this is not
  /// provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a
  /// variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are
  /// reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of
  /// whether the variable exists or not. Cannot be updated. More info:
  /// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  command: Listing<String>?

  /// List of environment variables to set in the container. Cannot be updated.
  env: Listing<Env>?

  /// List of sources to populate environment variables in the container. The keys defined within a
  /// source may consist of any printable ASCII characters except '='. When a key exists in multiple
  /// sources, the value associated with the last source will take precedence. Values defined by an Env
  /// with a duplicate key will take precedence. Cannot be updated.
  envFrom: Listing<EnvFrom>?

  /// Container image name. More info: https://kubernetes.io/docs/concepts/containers/images
  image: String?

  /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is
  /// specified, or IfNotPresent otherwise. Cannot be updated. More info:
  /// https://kubernetes.io/docs/concepts/containers/images#updating-images
  imagePullPolicy: String?

  /// Lifecycle is not allowed for ephemeral containers.
  lifecycle: Lifecycle?

  /// Probes are not allowed for ephemeral containers.
  livenessProbe: StartupProbe?

  /// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all
  /// containers, init containers and ephemeral containers.
  name: String

  /// Ports are not allowed for ephemeral containers.
  ports: Listing<Port>?

  /// Probes are not allowed for ephemeral containers.
  readinessProbe: StartupProbe?

  /// Resources resize policy for the container.
  resizePolicy: Listing<ResizePolicy>?

  /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
  /// already allocated to the pod.
  resources: Resources?

  /// Restart policy for the container to manage the restart behavior of each container within a pod. You
  /// cannot set this field on ephemeral containers.
  restartPolicy: String?

  /// Represents a list of rules to be checked to determine if the container should be restarted on exit.
  /// You cannot set this field on ephemeral containers.
  restartPolicyRules: Listing<RestartPolicyRule>?

  /// Optional: SecurityContext defines the security options the ephemeral container should be run with.
  /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
  securityContext: SecurityContext?

  /// Probes are not allowed for ephemeral containers.
  startupProbe: StartupProbe?

  /// Whether this container should allocate a buffer for stdin in the container runtime. If this is not
  /// set, reads from stdin in the container will always result in EOF. Default is false.
  stdin: Boolean?

  /// Whether the container runtime should close the stdin channel after it has been opened by a single
  /// attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If
  /// stdinOnce is set to true, stdin is opened on container start, is empty until the first client
  /// attaches to stdin, and then remains open and accepts data until the client disconnects, at which
  /// time stdin is closed and remains closed until the container is restarted. If this flag is false, a
  /// container processes that reads from stdin will never receive an EOF. Default is false
  stdinOnce: Boolean?

  /// If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral
  /// container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the
  /// ephemeral container uses the namespaces configured in the Pod spec.
  ///
  /// The container runtime must implement support for this feature. If the runtime does not support
  /// namespace targeting then the result of setting this field is undefined.
  targetContainerName: String?

  /// Optional: Path at which the file to which the container's termination message will be written is
  /// mounted into the container's filesystem. Message written is intended to be brief final status, such
  /// as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The
  /// total message length across all containers will be limited to 12kb. Defaults to
  /// /dev/termination-log. Cannot be updated.
  terminationMessagePath: String?

  /// Indicate how the termination message should be populated. File will use the contents of
  /// terminationMessagePath to populate the container status message on both success and failure.
  /// FallbackToLogsOnError will use the last chunk of container log output if the termination message
  /// file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80
  /// lines, whichever is smaller. Defaults to File. Cannot be updated.
  terminationMessagePolicy: String?

  /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default
  /// is false.
  tty: Boolean?

  /// volumeDevices is the list of block devices to be used by the container.
  volumeDevices: Listing<VolumeDevice>?

  /// Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral
  /// containers. Cannot be updated.
  volumeMounts: Listing<VolumeMount>?

  /// Container's working directory. If not specified, the container runtime's default will be used,
  /// which might be configured in the container image. Cannot be updated.
  workingDir: String?
}

/// Lifecycle is not allowed for ephemeral containers.
class Lifecycle {
  /// PostStart is called immediately after a container is created. If the handler fails, the container
  /// is terminated and restarted according to its restart policy. Other management of the container
  /// blocks until the hook completes. More info:
  /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  postStart: PostStart?

  /// PreStop is called immediately before a container is terminated due to an API request or management
  /// event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is
  /// not called if the container crashes or exits. The Pod's termination grace period countdown begins
  /// before the PreStop hook is executed. Regardless of the outcome of the handler, the container will
  /// eventually terminate within the Pod's termination grace period (unless delayed by finalizers).
  /// Other management of the container blocks until the hook completes or until the termination grace
  /// period is reached. More info:
  /// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  preStop: PreStop?

  /// StopSignal defines which signal will be sent to a container when it is being stopped. If not
  /// specified, the default is defined by the container runtime in use. StopSignal can only be set for
  /// Pods with a non-empty .spec.os.name
  stopSignal: String?
}

/// Probes are not allowed for ephemeral containers.
class StartupProbe {
  /// Exec specifies a command to execute in the container.
  exec: Exec?

  /// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults
  /// to 3. Minimum value is 1.
  failureThreshold: Int?

  /// GRPC specifies a GRPC HealthCheckRequest.
  grpc: Grpc?

  /// HTTPGet specifies an HTTP GET request to perform.
  httpGet: HttpGet?

  /// Number of seconds after the container has started before liveness probes are initiated. More info:
  /// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  initialDelaySeconds: Int?

  /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  periodSeconds: Int?

  /// Minimum consecutive successes for the probe to be considered successful after having failed.
  /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  successThreshold: Int?

  /// TCPSocket specifies a connection to a TCP port.
  tcpSocket: TcpSocket?

  /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace
  /// period is the duration in seconds after the processes running in the pod are sent a termination
  /// signal and the time when the processes are forcibly halted with a kill signal. Set this value
  /// longer than the expected cleanup time for your process. If this value is nil, the pod's
  /// terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by
  /// the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the
  /// kill signal (no opportunity to shut down). This is a beta field and requires enabling
  /// ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is
  /// used if unset.
  terminationGracePeriodSeconds: Int?

  /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More
  /// info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  timeoutSeconds: Int?
}

/// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources already
/// allocated to the pod.
class Resources {
  /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this
  /// container.
  ///
  /// This field depends on the DynamicResourceAllocation feature gate.
  ///
  /// This field is immutable. It can only be set for containers.
  claims: Listing<Claim>?

  /// Limits describes the maximum amount of compute resources allowed. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  limits: Mapping<String, Int|String>?

  /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a
  /// container, it defaults to Limits if that is explicitly specified, otherwise to an
  /// implementation-defined value. Requests cannot exceed Limits. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  requests: Mapping<String, Int|String>?
}

/// Optional: SecurityContext defines the security options the ephemeral container should be run with. If
/// set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
class SecurityContext {
  /// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent
  /// process. This bool directly controls if the no_new_privs flag will be set on the container process.
  /// AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has
  /// CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
  allowPrivilegeEscalation: Boolean?

  /// appArmorProfile is the AppArmor options to use by this container. If set, this profile overrides
  /// the pod's appArmorProfile. Note that this field cannot be set when spec.os.name is windows.
  appArmorProfile: AppArmorProfile?

  /// The capabilities to add/drop when running containers. Defaults to the default set of capabilities
  /// granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
  capabilities: Capabilities?

  /// Run container in privileged mode. Processes in privileged containers are essentially equivalent to
  /// root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is
  /// windows.
  privileged: Boolean?

  /// procMount denotes the type of proc mount to use for the containers. The default value is Default
  /// which uses the container runtime defaults for readonly paths and masked paths. This requires the
  /// ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is
  /// windows.
  procMount: String?

  /// Whether this container has a read-only root filesystem. Default is false. Note that this field
  /// cannot be set when spec.os.name is windows.
  readOnlyRootFilesystem: Boolean?

  /// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be
  /// set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value
  /// specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name
  /// is windows.
  runAsGroup: Int?

  /// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the
  /// image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if
  /// it does. If unset or false, no such validation will be performed. May also be set in
  /// PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in
  /// SecurityContext takes precedence.
  runAsNonRoot: Boolean?

  /// The UID to run the entrypoint of the container process. Defaults to user specified in image
  /// metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field
  /// cannot be set when spec.os.name is windows.
  runAsUser: Int?

  /// The SELinux context to be applied to the container. If unspecified, the container runtime will
  /// allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set
  /// in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
  /// precedence. Note that this field cannot be set when spec.os.name is windows.
  seLinuxOptions: SeLinuxOptions?

  /// The seccomp options to use by this container. If seccomp options are provided at both the pod &
  /// container level, the container options override the pod options. Note that this field cannot be set
  /// when spec.os.name is windows.
  seccompProfile: SeccompProfile?

  /// The Windows specific settings applied to all containers. If unspecified, the options from the
  /// PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value
  /// specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name
  /// is linux.
  windowsOptions: WindowsOptions?
}

/// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's
/// hosts file.
class HostAliase {
  /// Hostnames for the above IP address.
  hostnames: Listing<String>?

  /// IP address of the host file entry.
  ip: String
}

/// LocalObjectReference contains enough information to let you locate the referenced object inside the
/// same namespace.
class ImagePullSecret {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this
/// is set.
///
/// If the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions
///
/// If the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC -
/// spec.hostUsers - spec.resources - spec.securityContext.appArmorProfile -
/// spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile -
/// spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy -
/// spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser -
/// spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups -
/// spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile -
/// spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile
/// - spec.containers[*].securityContext.capabilities -
/// spec.containers[*].securityContext.readOnlyRootFilesystem -
/// spec.containers[*].securityContext.privileged -
/// spec.containers[*].securityContext.allowPrivilegeEscalation -
/// spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser -
/// spec.containers[*].securityContext.runAsGroup
class Os {
  /// Name is the name of the operating system. The currently supported values are linux and windows.
  /// Additional value may be defined in future and can be one of:
  /// https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
  /// Clients should expect to handle additional values and treat unrecognized values in this field as
  /// os: null
  name: String
}

/// PodReadinessGate contains the reference to a pod condition
class ReadinessGate {
  /// ConditionType refers to a condition in the pod's condition list with matching type.
  conditionType: String
}

/// PodResourceClaim references exactly one ResourceClaim, either directly or by naming a
/// ResourceClaimTemplate which is then turned into a ResourceClaim for the pod.
///
/// It adds a name to it that uniquely identifies the ResourceClaim inside the Pod. Containers that need
/// access to the ResourceClaim reference it with this name.
class ResourceClaim {
  /// Name uniquely identifies this resource claim inside the pod. This must be a DNS_LABEL.
  name: String

  /// ResourceClaimName is the name of a ResourceClaim object in the same namespace as this pod.
  ///
  /// Exactly one of ResourceClaimName and ResourceClaimTemplateName must be set.
  resourceClaimName: String?

  /// ResourceClaimTemplateName is the name of a ResourceClaimTemplate object in the same namespace as
  /// this pod.
  ///
  /// The template will be used to create a new ResourceClaim, which will be bound to this pod. When this
  /// pod is deleted, the ResourceClaim will also be deleted. The pod name and resource name, along with
  /// a generated component, will be used to form a unique name for the ResourceClaim, which will be
  /// recorded in pod.status.resourceClaimStatuses.
  ///
  /// This field is immutable and no changes will be made to the corresponding ResourceClaim by the
  /// control plane after creating the ResourceClaim.
  ///
  /// Exactly one of ResourceClaimName and ResourceClaimTemplateName must be set.
  resourceClaimTemplateName: String?
}

/// Resources is the total amount of CPU and Memory resources required by all containers in the pod. It
/// supports specifying Requests and Limits for "cpu", "memory" and "hugepages-" resource names only.
/// ResourceClaims are not supported.
///
/// This field enables fine-grained control over resource allocation for the entire pod, allowing
/// resource sharing among containers in a pod.
///
/// This is an alpha field and requires enabling the PodLevelResources feature gate.
class Resources {
  /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this
  /// container.
  ///
  /// This field depends on the DynamicResourceAllocation feature gate.
  ///
  /// This field is immutable. It can only be set for containers.
  claims: Listing<Claim>?

  /// Limits describes the maximum amount of compute resources allowed. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  limits: Mapping<String, Int|String>?

  /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a
  /// container, it defaults to Limits if that is explicitly specified, otherwise to an
  /// implementation-defined value. Requests cannot exceed Limits. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  requests: Mapping<String, Int|String>?
}

/// PodSchedulingGate is associated to a Pod to guard its scheduling.
class SchedulingGate {
  /// Name of the scheduling gate. Each scheduling gate must have a unique name field.
  name: String
}

/// SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults
/// to empty. See type description for default values of each field.
class SecurityContext {
  /// appArmorProfile is the AppArmor options to use by the containers in this pod. Note that this field
  /// cannot be set when spec.os.name is windows.
  appArmorProfile: AppArmorProfile?

  /// A special supplemental group that applies to all containers in a pod. Some volume types allow the
  /// Kubelet to change the ownership of that volume to be owned by the pod:
  ///
  /// 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume
  /// will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
  ///
  /// If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this
  /// field cannot be set when spec.os.name is windows.
  fsGroup: Int?

  /// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before
  /// being exposed inside Pod. This field will only apply to volume types which support fsGroup based
  /// ownership(and permissions). It will have no effect on ephemeral volume types such as: secret,
  /// configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always"
  /// is used. Note that this field cannot be set when spec.os.name is windows.
  fsGroupChangePolicy: String?

  /// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be
  /// set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified
  /// in SecurityContext takes precedence for that container. Note that this field cannot be set when
  /// spec.os.name is windows.
  runAsGroup: Int?

  /// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the
  /// image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if
  /// it does. If unset or false, no such validation will be performed. May also be set in
  /// SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in
  /// SecurityContext takes precedence.
  runAsNonRoot: Boolean?

  /// The UID to run the entrypoint of the container process. Defaults to user specified in image
  /// metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and
  /// PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
  /// Note that this field cannot be set when spec.os.name is windows.
  runAsUser: Int?

  /// seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the
  /// Pod. It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
  /// Valid values are "MountOption" and "Recursive".
  ///
  /// "Recursive" means relabeling of all files on all Pod volumes by the container runtime. This may be
  /// slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume
  /// on the same node.
  ///
  /// "MountOption" mounts all eligible Pod volumes with `-o context` mount option. This requires all
  /// Pods that share the same volume to use the same SELinux label. It is not possible to share the same
  /// volume among privileged and unprivileged Pods. Eligible volumes are in-tree FibreChannel and iSCSI
  /// volumes, and all CSI volumes whose CSI driver announces SELinux support by setting
  /// spec.seLinuxMount: true in their CSIDriver instance. Other volumes are always re-labelled
  /// recursively. "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
  ///
  /// If not specified and SELinuxMount feature gate is enabled, "MountOption" is used. If not specified
  /// and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes and
  /// "Recursive" for all other volumes.
  ///
  /// This field affects only Pods that have SELinux label set, either in PodSecurityContext or in
  /// SecurityContext of all containers.
  ///
  /// All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can
  /// get stuck in ContainerCreating state. Note that this field cannot be set when spec.os.name is
  /// windows.
  seLinuxChangePolicy: String?

  /// The SELinux context to be applied to all containers. If unspecified, the container runtime will
  /// allocate a random SELinux context for each container. May also be set in SecurityContext. If set in
  /// both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes
  /// precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  seLinuxOptions: SeLinuxOptions?

  /// The seccomp options to use by the containers in this pod. Note that this field cannot be set when
  /// spec.os.name is windows.
  seccompProfile: SeccompProfile?

  /// A list of groups applied to the first process run in each container, in addition to the container's
  /// primary GID and fsGroup (if specified). If the SupplementalGroupsPolicy feature is enabled, the
  /// supplementalGroupsPolicy field determines whether these are in addition to or instead of any group
  /// memberships defined in the container image. If unspecified, no additional groups are added, though
  /// group memberships defined in the container image may still be used, depending on the
  /// supplementalGroupsPolicy field. Note that this field cannot be set when spec.os.name is windows.
  supplementalGroups: Listing<Int>?

  /// Defines how supplemental groups of the first container processes are calculated. Valid values are
  /// "Merge" and "Strict". If not specified, "Merge" is used. (Alpha) Using the field requires the
  /// SupplementalGroupsPolicy feature gate to be enabled and the container runtime must implement
  /// support for this feature. Note that this field cannot be set when spec.os.name is windows.
  supplementalGroupsPolicy: String?

  /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the
  /// container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is
  /// windows.
  sysctls: Listing<Sysctl>?

  /// The Windows specific settings applied to all containers. If unspecified, the options within a
  /// container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext,
  /// the value specified in SecurityContext takes precedence. Note that this field cannot be set when
  /// spec.os.name is linux.
  windowsOptions: WindowsOptions?
}

/// appArmorProfile is the AppArmor options to use by the containers in this pod. Note that this field
/// cannot be set when spec.os.name is windows.
class AppArmorProfile {
  /// localhostProfile indicates a profile loaded on the node that should be used. The profile must be
  /// preconfigured on the node to work. Must match the loaded name of the profile. Must be set if and
  /// only if type is "Localhost".
  localhostProfile: String?

  /// type indicates which kind of AppArmor profile will be applied. Valid options are: Localhost - a
  /// profile pre-loaded on the node. RuntimeDefault - the container runtime's default profile.
  /// Unconfined - no AppArmor enforcement.
  type: String
}

/// The SELinux context to be applied to all containers. If unspecified, the container runtime will
/// allocate a random SELinux context for each container. May also be set in SecurityContext. If set in
/// both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence
/// for that container. Note that this field cannot be set when spec.os.name is windows.
class SeLinuxOptions {
  /// Level is SELinux level label that applies to the container.
  level: String?

  /// Role is a SELinux role label that applies to the container.
  role: String?

  /// Type is a SELinux type label that applies to the container.
  type: String?

  /// User is a SELinux user label that applies to the container.
  user: String?
}

/// The seccomp options to use by the containers in this pod. Note that this field cannot be set when
/// spec.os.name is windows.
class SeccompProfile {
  /// localhostProfile indicates a profile defined in a file on the node should be used. The profile must
  /// be preconfigured on the node to work. Must be a descending path, relative to the kubelet's
  /// configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any
  /// other type.
  localhostProfile: String?

  /// type indicates which kind of seccomp profile will be applied. Valid options are:
  ///
  /// Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container
  /// runtime default profile should be used. Unconfined - no profile should be applied.
  type: String
}

/// Sysctl defines a kernel parameter to be set
class Sysctl {
  /// Name of a property to set
  name: String

  /// Value of a property to set
  value: String
}

/// The Windows specific settings applied to all containers. If unspecified, the options within a
/// container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the
/// value specified in SecurityContext takes precedence. Note that this field cannot be set when
/// spec.os.name is linux.
class WindowsOptions {
  /// GMSACredentialSpec is where the GMSA admission webhook
  /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec
  /// named by the GMSACredentialSpecName field.
  gmsaCredentialSpec: String?

  /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
  gmsaCredentialSpecName: String?

  /// HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's
  /// containers must have the same effective HostProcess value (it is not allowed to have a mix of
  /// HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then
  /// HostNetwork must also be set to true.
  hostProcess: Boolean?

  /// The UserName in Windows to run the entrypoint of the container process. Defaults to the user
  /// specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both
  /// SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  runAsUserName: String?
}

/// The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect>
/// using the matching operator <operator>.
class Toleration {
  /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified,
  /// allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  effect: String?

  /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key
  /// is empty, operator must be Exists; this combination means to match all values and all keys.
  key: String?

  /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal.
  /// Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all
  /// taints of a particular category.
  operator: String?

  /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute,
  /// otherwise this field is ignored) tolerates the taint. By default, it is not set, which means
  /// tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict
  /// immediately) by the system.
  tolerationSeconds: Int?

  /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be
  /// empty, otherwise just a regular string.
  value: String?
}

/// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
class TopologySpreadConstraint {
  /// LabelSelector is used to find matching pods. Pods that match this label selector are counted to
  /// determine the number of pods in their corresponding topology domain.
  labelSelector: LabelSelector?

  /// MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be
  /// calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels
  /// are ANDed with labelSelector to select the group of existing pods over which spreading will be
  /// calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and
  /// LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in
  /// the incoming pod labels will be ignored. A null or empty list means only match against
  /// labelSelector.
  ///
  /// This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled
  /// (enabled by default).
  matchLabelKeys: Listing<String>?

  /// MaxSkew describes the degree to which pods may be unevenly distributed. When
  /// `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of
  /// matching pods in the target topology and the global minimum. The global minimum is the minimum
  /// number of matching pods in an eligible domain or zero if the number of eligible domains is less
  /// than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
  /// labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | | P
  /// P | P P | P | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
  /// scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1).
  /// - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When
  /// `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy
  /// it. It's a required field. Default value is 1 and 0 is not allowed.
  maxSkew: Int

  /// MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with
  /// matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0,
  /// and then the calculation of Skew is performed. And when the number of eligible domains with
  /// matching topology keys equals or greater than minDomains, this value has no effect on scheduling.
  /// As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule
  /// more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains
  /// is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable
  /// must be DoNotSchedule.
  ///
  /// For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the
  /// same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P | The number of
  /// domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod
  /// with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod
  /// is scheduled to any of the three zones, it will violate MaxSkew.
  minDomains: Int?

  /// NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod
  /// topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are
  /// included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are
  /// included in the calculations.
  ///
  /// If this value is nil, the behavior is equivalent to the Honor policy.
  nodeAffinityPolicy: String?

  /// NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew.
  /// Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has
  /// a toleration, are included. - Ignore: node taints are ignored. All nodes are included.
  ///
  /// If this value is nil, the behavior is equivalent to the Ignore policy.
  nodeTaintsPolicy: String?

  /// TopologyKey is the key of node labels. Nodes that have a label with this key and identical values
  /// are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to
  /// put balanced number of pods into each bucket. We define a domain as a particular instance of a
  /// topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of
  /// nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node
  /// is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a
  /// domain of that topology. It's a required field.
  topologyKey: String

  /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. -
  /// DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the
  /// scheduler to schedule the pod in any location, but giving higher precedence to topologies that
  /// would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and
  /// only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For
  /// example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as
  /// 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
  /// incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on
  /// zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but
  /// scheduler won't make it *more* imbalanced. It's a required field.
  whenUnsatisfiable: String
}

/// LabelSelector is used to find matching pods. Pods that match this label selector are counted to
/// determine the number of pods in their corresponding topology domain.
class LabelSelector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// Volume represents a named volume in a pod that may be accessed by any container in the pod.
class Volume {
  /// awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine
  /// and then exposed to the pod. Deprecated: AWSElasticBlockStore is deprecated. All operations for the
  /// in-tree awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  awsElasticBlockStore: AwsElasticBlockStore?

  /// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Deprecated:
  /// AzureDisk is deprecated. All operations for the in-tree azureDisk type are redirected to the
  /// disk.csi.azure.com CSI driver.
  azureDisk: AzureDisk?

  /// azureFile represents an Azure File Service mount on the host and bind mount to the pod. Deprecated:
  /// AzureFile is deprecated. All operations for the in-tree azureFile type are redirected to the
  /// file.csi.azure.com CSI driver.
  azureFile: AzureFile?

  /// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime. Deprecated: CephFS is
  /// deprecated and the in-tree cephfs type is no longer supported.
  cephfs: Cephfs?

  /// cinder represents a cinder volume attached and mounted on kubelets host machine. Deprecated: Cinder
  /// is deprecated. All operations for the in-tree cinder type are redirected to the
  /// cinder.csi.openstack.org CSI driver. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  cinder: Cinder?

  /// configMap represents a configMap that should populate this volume
  configMap: ConfigMap?

  /// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external
  /// CSI drivers.
  csi: Csi?

  /// downwardAPI represents downward API about the pod that should populate this volume
  downwardAPI: DownwardAPI?

  /// emptyDir represents a temporary directory that shares a pod's lifetime. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  emptyDir: EmptyDir?

  /// ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle
  /// is tied to the pod that defines it - it will be created before the pod starts, and deleted when the
  /// pod is removed.
  ///
  /// Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like
  /// restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through
  /// a storage class, and d) the storage driver supports dynamic volume provisioning through a
  /// PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between
  /// this volume type and PersistentVolumeClaim).
  ///
  /// Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer
  /// than the lifecycle of an individual pod.
  ///
  /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way -
  /// see the documentation of the driver for more information.
  ///
  /// A pod can use both types of ephemeral volumes and persistent volumes at the same time.
  ephemeral: Ephemeral?

  /// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then
  /// exposed to the pod.
  fc: Fc?

  /// flexVolume represents a generic volume resource that is provisioned/attached using an exec based
  /// plugin. Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
  flexVolume: FlexVolume?

  /// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the
  /// Flocker control service being running. Deprecated: Flocker is deprecated and the in-tree flocker
  /// type is no longer supported.
  flocker: Flocker?

  /// gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and
  /// then exposed to the pod. Deprecated: GCEPersistentDisk is deprecated. All operations for the
  /// in-tree gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  gcePersistentDisk: GcePersistentDisk?

  /// gitRepo represents a git repository at a particular revision. Deprecated: GitRepo is deprecated. To
  /// provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo
  /// using git, then mount the EmptyDir into the Pod's container.
  gitRepo: GitRepo?

  /// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. Deprecated:
  /// Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
  glusterfs: Glusterfs?

  /// hostPath represents a pre-existing file or directory on the host machine that is directly exposed
  /// to the container. This is generally used for system agents or other privileged things that are
  /// allowed to see the host machine. Most containers will NOT need this. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  hostPath: HostPath?

  /// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's
  /// host machine. The volume is resolved at pod startup depending on which PullPolicy value is
  /// provided:
  ///
  /// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the
  /// pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact.
  /// Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if
  /// the reference isn't already present on disk. Container creation will fail if the reference isn't
  /// present and the pull fails.
  ///
  /// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote
  /// content will become available on pod recreation. A failure to resolve or pull the image during pod
  /// startup will block containers from starting and may add significant latency. Failures will be
  /// retried using normal volume backoff and will be reported on the pod reason and message. The types
  /// of objects that may be mounted by this volume are defined by the container runtime implementation
  /// on a host machine and at minimum must include all valid types supported by the container image
  /// field. The OCI object gets mounted in a single directory
  /// (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for
  /// container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub
  /// path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
  /// The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
  image: Image?

  /// iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then
  /// exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi
  iscsi: Iscsi?

  /// name of the volume. Must be a DNS_LABEL and unique within the pod. More info:
  /// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String

  /// nfs represents an NFS mount on the host that shares a pod's lifetime More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
  nfs: Nfs?

  /// persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same
  /// namespace. More info:
  /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  persistentVolumeClaim: PersistentVolumeClaim?

  /// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets
  /// host machine. Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk
  /// type is no longer supported.
  photonPersistentDisk: PhotonPersistentDisk?

  /// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
  /// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type are
  /// redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate is on.
  portworxVolume: PortworxVolume?

  /// projected items for all in one resources secrets, configmaps, and downward API
  projected: Projected?

  /// quobyte represents a Quobyte mount on the host that shares a pod's lifetime. Deprecated: Quobyte is
  /// deprecated and the in-tree quobyte type is no longer supported.
  quobyte: Quobyte?

  /// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. Deprecated: RBD
  /// is deprecated and the in-tree rbd type is no longer supported.
  rbd: Rbd?

  /// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  /// Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
  scaleIO: ScaleIO?

  /// secret represents a secret that should populate this volume. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#secret
  secret: Secret?

  /// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes. Deprecated:
  /// StorageOS is deprecated and the in-tree storageos type is no longer supported.
  storageos: Storageos?

  /// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
  /// Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type are
  /// redirected to the csi.vsphere.vmware.com CSI driver.
  vsphereVolume: VsphereVolume?
}

/// awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and
/// then exposed to the pod. Deprecated: AWSElasticBlockStore is deprecated. All operations for the
/// in-tree awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver. More info:
/// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
class AwsElasticBlockStore {
  /// fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
  /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
  /// inferred to be "ext4" if unspecified. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  fsType: String?

  /// partition is the partition in the volume that you want to mount. If omitted, the default is to
  /// mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly,
  /// the volume partition for /dev/sda is "0" (or you can leave the property empty).
  partition: Int?

  /// readOnly value true will force the readOnly setting in VolumeMounts. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  readOnly: Boolean?

  /// volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  volumeID: String
}

/// azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Deprecated:
/// AzureDisk is deprecated. All operations for the in-tree azureDisk type are redirected to the
/// disk.csi.azure.com CSI driver.
class AzureDisk {
  /// cachingMode is the Host Caching mode: None, Read Only, Read Write.
  cachingMode: String?

  /// diskName is the Name of the data disk in the blob storage
  diskName: String

  /// diskURI is the URI of data disk in the blob storage
  diskURI: String

  /// fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  fsType: String?

  /// kind expected values are Shared: multiple blob disks per storage account Dedicated: single blob
  /// disk per storage account Managed: azure managed data disk (only in managed availability set).
  /// defaults to shared
  kind: String?

  /// readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
  /// VolumeMounts.
  readOnly: Boolean?
}

/// azureFile represents an Azure File Service mount on the host and bind mount to the pod. Deprecated:
/// AzureFile is deprecated. All operations for the in-tree azureFile type are redirected to the
/// file.csi.azure.com CSI driver.
class AzureFile {
  /// readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
  /// VolumeMounts.
  readOnly: Boolean?

  /// secretName is the name of secret that contains Azure Storage Account Name and Key
  secretName: String

  /// shareName is the azure share Name
  shareName: String
}

/// cephFS represents a Ceph FS mount on the host that shares a pod's lifetime. Deprecated: CephFS is
/// deprecated and the in-tree cephfs type is no longer supported.
class Cephfs {
  /// monitors is Required: Monitors is a collection of Ceph monitors More info:
  /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  monitors: Listing<String>

  /// path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  path: String?

  /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
  /// in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  readOnly: Boolean?

  /// secretFile is Optional: SecretFile is the path to key ring for User, default is
  /// /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  secretFile: String?

  /// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is
  /// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  secretRef: SecretRef?

  /// user is optional: User is the rados user name, default is admin More info:
  /// https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  user: String?
}

/// secretRef is Optional: SecretRef is reference to the authentication secret for User, default is
/// empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// cinder represents a cinder volume attached and mounted on kubelets host machine. Deprecated: Cinder
/// is deprecated. All operations for the in-tree cinder type are redirected to the
/// cinder.csi.openstack.org CSI driver. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
class Cinder {
  /// fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More
  /// info: https://examples.k8s.io/mysql-cinder-pd/README.md
  fsType: String?

  /// readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
  /// VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  readOnly: Boolean?

  /// secretRef is optional: points to a secret object containing parameters used to connect to
  /// OpenStack.
  secretRef: SecretRef?

  /// volumeID used to identify the volume in cinder. More info:
  /// https://examples.k8s.io/mysql-cinder-pd/README.md
  volumeID: String
}

/// secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// configMap represents a configMap that should populate this volume
class ConfigMap {
  /// defaultMode is optional: mode bits used to set permissions on created files by default. Must be an
  /// octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and
  /// decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within
  /// the path are not affected by this setting. This might be in conflict with other options that affect
  /// the file mode, like fsGroup, and the result can be other mode bits set.
  defaultMode: Int?

  /// items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be
  /// projected into the volume as a file whose name is the key and content is the value. If specified,
  /// the listed keys will be projected into the specified paths, and unlisted keys will not be present.
  /// If a key is specified which is not present in the ConfigMap, the volume setup will error unless it
  /// is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
  items: Listing<Item>?

  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?

  /// optional specify whether the ConfigMap or its keys must be defined
  optional: Boolean?
}

/// Maps a string key to a path within a volume.
class Item {
  /// key is the key to project.
  key: String

  /// mode is Optional: mode bits used to set permissions on this file. Must be an octal value between
  /// 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values,
  /// JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used.
  /// This might be in conflict with other options that affect the file mode, like fsGroup, and the
  /// result can be other mode bits set.
  mode: Int?

  /// path is the relative path of the file to map the key to. May not be an absolute path. May not
  /// contain the path element '..'. May not start with the string '..'.
  path: String
}

/// csi (Container Storage Interface) represents ephemeral storage that is handled by certain external
/// CSI drivers.
class Csi {
  /// driver is the name of the CSI driver that handles this volume. Consult with your admin for the
  /// correct name as registered in the cluster.
  driver: String

  /// fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the
  /// associated CSI driver which will determine the default filesystem to apply.
  fsType: String?

  /// nodePublishSecretRef is a reference to the secret object containing sensitive information to pass
  /// to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field
  /// is optional, and may be empty if no secret is required. If the secret object contains more than one
  /// secret, all secret references are passed.
  nodePublishSecretRef: NodePublishSecretRef?

  /// readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
  readOnly: Boolean?

  /// volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your
  /// driver's documentation for supported values.
  volumeAttributes: Mapping<String, String>?
}

/// nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to
/// the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is
/// optional, and may be empty if no secret is required. If the secret object contains more than one
/// secret, all secret references are passed.
class NodePublishSecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// downwardAPI represents downward API about the pod that should populate this volume
class DownwardAPI {
  /// Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set
  /// permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal
  /// value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values
  /// for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This
  /// might be in conflict with other options that affect the file mode, like fsGroup, and the result can
  /// be other mode bits set.
  defaultMode: Int?

  /// Items is a list of downward API volume file
  items: Listing<Item>?
}

/// DownwardAPIVolumeFile represents information to create the file containing the pod field
class Item {
  /// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are
  /// supported.
  fieldRef: FieldRef?

  /// Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and
  /// 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON
  /// requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This
  /// might be in conflict with other options that affect the file mode, like fsGroup, and the result can
  /// be other mode bits set.
  mode: Int?

  /// Required: Path is the relative path name of the file to be created. Must not be absolute or contain
  /// the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  path: String

  /// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory,
  /// requests.cpu and requests.memory) are currently supported.
  resourceFieldRef: ResourceFieldRef?
}

/// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are
/// supported.
class FieldRef {
  /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
  apiVersion: String?

  /// Path of the field to select in the specified API version.
  fieldPath: String
}

/// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory,
/// requests.cpu and requests.memory) are currently supported.
class ResourceFieldRef {
  /// Container name: required for volumes, optional for env vars
  containerName: String?

  /// Specifies the output format of the exposed resources, defaults to "1"
  divisor: (Int|String)?

  /// Required: resource to select
  resource: String
}

/// emptyDir represents a temporary directory that shares a pod's lifetime. More info:
/// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
class EmptyDir {
  /// medium represents what type of storage medium should back this directory. The default is "" which
  /// means to use the node's default medium. Must be an empty string (default) or Memory. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  medium: String?

  /// sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is
  /// also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum
  /// value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
  /// The default is nil which means that the limit is undefined. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  sizeLimit: (Int|String)?
}

/// ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is
/// tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod
/// is removed.
///
/// Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like
/// restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a
/// storage class, and d) the storage driver supports dynamic volume provisioning through a
/// PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this
/// volume type and PersistentVolumeClaim).
///
/// Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than
/// the lifecycle of an individual pod.
///
/// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see
/// the documentation of the driver for more information.
///
/// A pod can use both types of ephemeral volumes and persistent volumes at the same time.
class Ephemeral {
  /// Will be used to create a stand-alone PVC to provision the volume. The pod in which this
  /// EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted
  /// together with the pod. The name of the PVC will be `<pod name>-<volume name>` where `<volume name>`
  /// is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the
  /// concatenated name is not valid for a PVC (for example, too long).
  ///
  /// An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid
  /// using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is
  /// removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an
  /// owner reference to the pod once the pod exists. Normally this should not be necessary, but it may
  /// be useful when manually reconstructing a broken cluster.
  ///
  /// This field is read-only and no changes will be made by Kubernetes to the PVC after it has been
  /// created.
  ///
  /// Required, must not be nil.
  volumeClaimTemplate: VolumeClaimTemplate?
}

/// Will be used to create a stand-alone PVC to provision the volume. The pod in which this
/// EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together
/// with the pod. The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the
/// name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated
/// name is not valid for a PVC (for example, too long).
///
/// An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid
/// using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is
/// removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an
/// owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be
/// useful when manually reconstructing a broken cluster.
///
/// This field is read-only and no changes will be made by Kubernetes to the PVC after it has been
/// created.
///
/// Required, must not be nil.
class VolumeClaimTemplate {
  /// May contain labels and annotations that will be copied into the PVC when creating it. No other
  /// fields are allowed and will be rejected during validation.
  metadata: Dynamic?

  /// The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the
  /// PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also
  /// valid here.
  spec: Spec
}

/// The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC
/// that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid
/// here.
class Spec {
  /// accessModes contains the desired access modes the volume should have. More info:
  /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  accessModes: Listing<String>?

  /// dataSource field can be used to specify either: * An existing VolumeSnapshot object
  /// (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the
  /// provisioner or an external controller can support the specified data source, it will create a new
  /// volume based on the contents of the specified data source. When the AnyVolumeDataSource feature
  /// gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents
  /// will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is
  /// specified, then dataSourceRef will not be copied to dataSource.
  dataSource: DataSource?

  /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
  /// volume is desired. This may be any object from a non-empty API group (non core object) or a
  /// PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the
  /// type of the specified object matches some installed volume populator or dynamic provisioner. This
  /// field will replace the functionality of the dataSource field and as such if both fields are
  /// non-empty, they must have the same value. For backwards compatibility, when namespace isn't
  /// specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same
  /// value automatically if one of them is empty and the other is non-empty. When namespace is specified
  /// in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three
  /// important differences between dataSource and dataSourceRef: * While dataSource only allows two
  /// specific types of objects, dataSourceRef allows any non-core object, as well as
  /// PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them),
  /// dataSourceRef preserves all values, and generates an error if a disallowed value is specified. *
  /// While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta)
  /// Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the
  /// namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be
  /// enabled.
  dataSourceRef: DataSourceRef?

  /// resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure
  /// feature is enabled users are allowed to specify resource requirements that are lower than previous
  /// value but must still be higher than capacity recorded in the status field of the claim. More info:
  /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  resources: Resources?

  /// selector is a label query over volumes to consider for binding.
  selector: Selector?

  /// storageClassName is the name of the StorageClass required by the claim. More info:
  /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  storageClassName: String?

  /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If
  /// specified, the CSI driver will create or update the volume with the attributes defined in the
  /// corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be
  /// changed after the claim is created. An empty string or nil value indicates that no
  /// VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,
  /// this field can be reset to its previous value (including nil) to cancel the modification. If the
  /// resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
  /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
  /// exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
  volumeAttributesClassName: String?

  /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied
  /// when not included in claim spec.
  volumeMode: String?

  /// volumeName is the binding reference to the PersistentVolume backing this claim.
  volumeName: String?
}

/// dataSource field can be used to specify either: * An existing VolumeSnapshot object
/// (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner
/// or an external controller can support the specified data source, it will create a new volume based on
/// the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled,
/// dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to
/// dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then
/// dataSourceRef will not be copied to dataSource.
class DataSource {
  /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the
  /// specified Kind must be in the core API group. For any other third-party types, APIGroup is
  /// required.
  apiGroup: String?

  /// Kind is the type of resource being referenced
  kind: String

  /// Name is the name of resource being referenced
  name: String
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume
/// is desired. This may be any object from a non-empty API group (non core object) or a
/// PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the
/// type of the specified object matches some installed volume populator or dynamic provisioner. This
/// field will replace the functionality of the dataSource field and as such if both fields are
/// non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified
/// in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value
/// automatically if one of them is empty and the other is non-empty. When namespace is specified in
/// dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important
/// differences between dataSource and dataSourceRef: * While dataSource only allows two specific types
/// of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. *
/// While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and
/// generates an error if a disallowed value is specified. * While dataSource only allows local objects,
/// dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the
/// AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef
/// requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
class DataSourceRef {
  /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the
  /// specified Kind must be in the core API group. For any other third-party types, APIGroup is
  /// required.
  apiGroup: String?

  /// Kind is the type of resource being referenced
  kind: String

  /// Name is the name of resource being referenced
  name: String

  /// Namespace is the namespace of resource being referenced Note that when a namespace is specified, a
  /// gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that
  /// namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
  /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
  namespace: String?
}

/// resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure
/// feature is enabled users are allowed to specify resource requirements that are lower than previous
/// value but must still be higher than capacity recorded in the status field of the claim. More info:
/// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
class Resources {
  /// Limits describes the maximum amount of compute resources allowed. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  limits: Mapping<String, Int|String>?

  /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a
  /// container, it defaults to Limits if that is explicitly specified, otherwise to an
  /// implementation-defined value. Requests cannot exceed Limits. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  requests: Mapping<String, Int|String>?
}

/// selector is a label query over volumes to consider for binding.
class Selector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed
/// to the pod.
class Fc {
  /// fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  fsType: String?

  /// lun is Optional: FC target lun number
  lun: Int?

  /// readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting
  /// in VolumeMounts.
  readOnly: Boolean?

  /// targetWWNs is Optional: FC target worldwide names (WWNs)
  targetWWNs: Listing<String>?

  /// wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs
  /// and lun must be set, but not both simultaneously.
  wwids: Listing<String>?
}

/// flexVolume represents a generic volume resource that is provisioned/attached using an exec based
/// plugin. Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
class FlexVolume {
  /// driver is the name of the driver to use for this volume.
  driver: String

  /// fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  fsType: String?

  /// options is Optional: this field holds extra command options if any.
  options: Mapping<String, String>?

  /// readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting
  /// in VolumeMounts.
  readOnly: Boolean?

  /// secretRef is Optional: secretRef is reference to the secret object containing sensitive information
  /// to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret
  /// object contains more than one secret, all secrets are passed to the plugin scripts.
  secretRef: SecretRef?
}

/// secretRef is Optional: secretRef is reference to the secret object containing sensitive information
/// to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret
/// object contains more than one secret, all secrets are passed to the plugin scripts.
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker
/// control service being running. Deprecated: Flocker is deprecated and the in-tree flocker type is no
/// longer supported.
class Flocker {
  /// datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be
  /// considered as deprecated
  datasetName: String?

  /// datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
  datasetUUID: String?
}

/// gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and
/// then exposed to the pod. Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
/// gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver. More info:
/// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
class GcePersistentDisk {
  /// fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
  /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
  /// inferred to be "ext4" if unspecified. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  fsType: String?

  /// partition is the partition in the volume that you want to mount. If omitted, the default is to
  /// mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly,
  /// the volume partition for /dev/sda is "0" (or you can leave the property empty). More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  partition: Int?

  /// pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  pdName: String

  /// readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  readOnly: Boolean?
}

/// gitRepo represents a git repository at a particular revision. Deprecated: GitRepo is deprecated. To
/// provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo
/// using git, then mount the EmptyDir into the Pod's container.
class GitRepo {
  /// directory is the target directory name. Must not contain or start with '..'. If '.' is supplied,
  /// the volume directory will be the git repository. Otherwise, if specified, the volume will contain
  /// the git repository in the subdirectory with the given name.
  directory: String?

  /// repository is the URL
  repository: String

  /// revision is the commit hash for the specified revision.
  revision: String?
}

/// glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. Deprecated:
/// Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
class Glusterfs {
  /// endpoints is the endpoint name that details Glusterfs topology.
  endpoints: String

  /// path is the Glusterfs volume path. More info:
  /// https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  path: String

  /// readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to
  /// false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  readOnly: Boolean?
}

/// hostPath represents a pre-existing file or directory on the host machine that is directly exposed to
/// the container. This is generally used for system agents or other privileged things that are allowed
/// to see the host machine. Most containers will NOT need this. More info:
/// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
class HostPath {
  /// path of the directory on the host. If the path is a symlink, it will follow the link to the real
  /// path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  path: String

  /// type for HostPath Volume Defaults to "" More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  type: String?
}

/// image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's
/// host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:
///
/// - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull
/// fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact.
/// Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the
/// reference isn't already present on disk. Container creation will fail if the reference isn't present
/// and the pull fails.
///
/// The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote
/// content will become available on pod recreation. A failure to resolve or pull the image during pod
/// startup will block containers from starting and may add significant latency. Failures will be retried
/// using normal volume backoff and will be reported on the pod reason and message. The types of objects
/// that may be mounted by this volume are defined by the container runtime implementation on a host
/// machine and at minimum must include all valid types supported by the container image field. The OCI
/// object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the
/// manifest layers in the same way as for container images. The volume will be mounted read-only (ro)
/// and non-executable files (noexec). Sub path mounts for containers are not supported
/// (spec.containers[*].volumeMounts.subpath) before 1.33. The field
/// spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
class Image {
  /// Policy for pulling OCI objects. Possible values are: Always: the kubelet always attempts to pull
  /// the reference. Container creation will fail If the pull fails. Never: the kubelet never pulls the
  /// reference and only uses a local image or artifact. Container creation will fail if the reference
  /// isn't present. IfNotPresent: the kubelet pulls if the reference isn't already present on disk.
  /// Container creation will fail if the reference isn't present and the pull fails. Defaults to Always
  /// if :latest tag is specified, or IfNotPresent otherwise.
  pullPolicy: String?

  /// Required: Image or artifact reference to be used. Behaves in the same way as
  /// pod.spec.containers[*].image. Pull secrets will be assembled in the same way as for the container
  /// image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets. More
  /// info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher
  /// level config management to default or override container images in workload controllers like
  /// Deployments and StatefulSets.
  reference: String?
}

/// iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed
/// to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi
class Iscsi {
  /// chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
  chapAuthDiscovery: Boolean?

  /// chapAuthSession defines whether support iSCSI Session CHAP authentication
  chapAuthSession: Boolean?

  /// fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
  /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
  /// inferred to be "ext4" if unspecified. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  fsType: String?

  /// initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface
  /// simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the
  /// connection.
  initiatorName: String?

  /// iqn is the target iSCSI Qualified Name.
  iqn: String

  /// iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
  iscsiInterface: String?

  /// lun represents iSCSI Target Lun number.
  lun: Int

  /// portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is
  /// other than default (typically TCP ports 860 and 3260).
  portals: Listing<String>?

  /// readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
  readOnly: Boolean?

  /// secretRef is the CHAP Secret for iSCSI target and initiator authentication
  secretRef: SecretRef?

  /// targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is
  /// other than default (typically TCP ports 860 and 3260).
  targetPortal: String
}

/// secretRef is the CHAP Secret for iSCSI target and initiator authentication
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// nfs represents an NFS mount on the host that shares a pod's lifetime More info:
/// https://kubernetes.io/docs/concepts/storage/volumes#nfs
class Nfs {
  /// path that is exported by the NFS server. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
  path: String

  /// readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to
  /// false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  readOnly: Boolean?

  /// server is the hostname or IP address of the NFS server. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#nfs
  server: String
}

/// persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same
/// namespace. More info:
/// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
class PersistentVolumeClaim {
  /// claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this
  /// volume. More info:
  /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  claimName: String

  /// readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
  readOnly: Boolean?
}

/// photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets
/// host machine. Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk
/// type is no longer supported.
class PhotonPersistentDisk {
  /// fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  fsType: String?

  /// pdID is the ID that identifies Photon Controller persistent disk
  pdID: String
}

/// portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
/// Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type are
/// redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate is on.
class PortworxVolume {
  /// fSType represents the filesystem type to mount Must be a filesystem type supported by the host
  /// operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
  fsType: String?

  /// readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
  /// VolumeMounts.
  readOnly: Boolean?

  /// volumeID uniquely identifies a Portworx volume
  volumeID: String
}

/// projected items for all in one resources secrets, configmaps, and downward API
class Projected {
  /// defaultMode are the mode bits used to set permissions on created files by default. Must be an octal
  /// value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and
  /// decimal values, JSON requires decimal values for mode bits. Directories within the path are not
  /// affected by this setting. This might be in conflict with other options that affect the file mode,
  /// like fsGroup, and the result can be other mode bits set.
  defaultMode: Int?

  /// sources is the list of volume projections. Each entry in this list handles one source.
  sources: Listing<Source>?
}

/// Projection that may be projected along with other supported volume types. Exactly one of these fields
/// must be set.
class Source {
  /// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field of ClusterTrustBundle
  /// objects in an auto-updating file.
  ///
  /// Alpha, gated by the ClusterTrustBundleProjection feature gate.
  ///
  /// ClusterTrustBundle objects can either be selected by name, or by the combination of signer name and
  /// a label selector.
  ///
  /// Kubelet performs aggressive normalization of the PEM contents written into the pod filesystem.
  /// Esoteric PEM features such as inter-block comments and block headers are stripped. Certificates are
  /// deduplicated. The ordering of certificates within the file is arbitrary, and Kubelet may change the
  /// order over time.
  clusterTrustBundle: ClusterTrustBundle?

  /// configMap information about the configMap data to project
  configMap: ConfigMap?

  /// downwardAPI information about the downwardAPI data to project
  downwardAPI: DownwardAPI?

  /// Projects an auto-rotating credential bundle (private key and certificate chain) that the pod can
  /// use either as a TLS client or server.
  ///
  /// Kubelet generates a private key and uses it to send a PodCertificateRequest to the named signer.
  /// Once the signer approves the request and issues a certificate chain, Kubelet writes the key and
  /// certificate chain to the pod filesystem. The pod does not start until certificates have been issued
  /// for each podCertificate projected volume source in its spec.
  ///
  /// Kubelet will begin trying to rotate the certificate at the time indicated by the signer using the
  /// PodCertificateRequest.Status.BeginRefreshAt timestamp.
  ///
  /// Kubelet can write a single file, indicated by the credentialBundlePath field, or separate files,
  /// indicated by the keyPath and certificateChainPath fields.
  ///
  /// The credential bundle is a single file in PEM format. The first PEM entry is the private key (in
  /// PKCS#8 format), and the remaining PEM entries are the certificate chain issued by the signer
  /// (typically, signers will return their certificate chain in leaf-to-root order).
  ///
  /// Prefer using the credential bundle format, since your application code can read it atomically. If
  /// you use keyPath and certificateChainPath, your application must make two separate file reads. If
  /// these coincide with a certificate rotation, it is possible that the private key and leaf
  /// certificate you read may not correspond to each other. Your application will need to check for this
  /// condition, and re-read until they are consistent.
  ///
  /// The named signer controls chooses the format of the certificate it issues; consult the signer
  /// implementation's documentation to learn how to use the certificates it issues.
  podCertificate: PodCertificate?

  /// secret information about the secret data to project
  secret: Secret?

  /// serviceAccountToken is information about the serviceAccountToken data to project
  serviceAccountToken: ServiceAccountToken?
}

/// ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field of ClusterTrustBundle objects
/// in an auto-updating file.
///
/// Alpha, gated by the ClusterTrustBundleProjection feature gate.
///
/// ClusterTrustBundle objects can either be selected by name, or by the combination of signer name and a
/// label selector.
///
/// Kubelet performs aggressive normalization of the PEM contents written into the pod filesystem.
/// Esoteric PEM features such as inter-block comments and block headers are stripped. Certificates are
/// deduplicated. The ordering of certificates within the file is arbitrary, and Kubelet may change the
/// order over time.
class ClusterTrustBundle {
  /// Select all ClusterTrustBundles that match this label selector. Only has effect if signerName is
  /// set. Mutually-exclusive with name. If unset, interpreted as "match nothing". If set but empty,
  /// interpreted as "match everything".
  labelSelector: LabelSelector?

  /// Select a single ClusterTrustBundle by object name. Mutually-exclusive with signerName and
  /// labelSelector.
  name: String?

  /// If true, don't block pod startup if the referenced ClusterTrustBundle(s) aren't available. If using
  /// name, then the named ClusterTrustBundle is allowed not to exist. If using signerName, then the
  /// combination of signerName and labelSelector is allowed to match zero ClusterTrustBundles.
  optional: Boolean?

  /// Relative path from the volume root to write the bundle.
  path: String

  /// Select all ClusterTrustBundles that match this signer name. Mutually-exclusive with name. The
  /// contents of all selected ClusterTrustBundles will be unified and deduplicated.
  signerName: String?
}

/// Select all ClusterTrustBundles that match this label selector. Only has effect if signerName is set.
/// Mutually-exclusive with name. If unset, interpreted as "match nothing". If set but empty, interpreted
/// as "match everything".
class LabelSelector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// configMap information about the configMap data to project
class ConfigMap {
  /// items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be
  /// projected into the volume as a file whose name is the key and content is the value. If specified,
  /// the listed keys will be projected into the specified paths, and unlisted keys will not be present.
  /// If a key is specified which is not present in the ConfigMap, the volume setup will error unless it
  /// is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
  items: Listing<Item>?

  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?

  /// optional specify whether the ConfigMap or its keys must be defined
  optional: Boolean?
}

/// downwardAPI information about the downwardAPI data to project
class DownwardAPI {
  /// Items is a list of DownwardAPIVolume file
  items: Listing<Item>?
}

/// Projects an auto-rotating credential bundle (private key and certificate chain) that the pod can use
/// either as a TLS client or server.
///
/// Kubelet generates a private key and uses it to send a PodCertificateRequest to the named signer. Once
/// the signer approves the request and issues a certificate chain, Kubelet writes the key and
/// certificate chain to the pod filesystem. The pod does not start until certificates have been issued
/// for each podCertificate projected volume source in its spec.
///
/// Kubelet will begin trying to rotate the certificate at the time indicated by the signer using the
/// PodCertificateRequest.Status.BeginRefreshAt timestamp.
///
/// Kubelet can write a single file, indicated by the credentialBundlePath field, or separate files,
/// indicated by the keyPath and certificateChainPath fields.
///
/// The credential bundle is a single file in PEM format. The first PEM entry is the private key (in
/// PKCS#8 format), and the remaining PEM entries are the certificate chain issued by the signer
/// (typically, signers will return their certificate chain in leaf-to-root order).
///
/// Prefer using the credential bundle format, since your application code can read it atomically. If you
/// use keyPath and certificateChainPath, your application must make two separate file reads. If these
/// coincide with a certificate rotation, it is possible that the private key and leaf certificate you
/// read may not correspond to each other. Your application will need to check for this condition, and
/// re-read until they are consistent.
///
/// The named signer controls chooses the format of the certificate it issues; consult the signer
/// implementation's documentation to learn how to use the certificates it issues.
class PodCertificate {
  /// Write the certificate chain at this path in the projected volume.
  ///
  /// Most applications should use credentialBundlePath. When using keyPath and certificateChainPath,
  /// your application needs to check that the key and leaf certificate are consistent, because it is
  /// possible to read the files mid-rotation.
  certificateChainPath: String?

  /// Write the credential bundle at this path in the projected volume.
  ///
  /// The credential bundle is a single file that contains multiple PEM blocks. The first PEM block is a
  /// PRIVATE KEY block, containing a PKCS#8 private key.
  ///
  /// The remaining blocks are CERTIFICATE blocks, containing the issued certificate chain from the
  /// signer (leaf and any intermediates).
  ///
  /// Using credentialBundlePath lets your Pod's application code make a single atomic read that
  /// retrieves a consistent key and certificate chain. If you project them to separate files, your
  /// application code will need to additionally check that the leaf certificate was issued to the key.
  credentialBundlePath: String?

  /// Write the key at this path in the projected volume.
  ///
  /// Most applications should use credentialBundlePath. When using keyPath and certificateChainPath,
  /// your application needs to check that the key and leaf certificate are consistent, because it is
  /// possible to read the files mid-rotation.
  keyPath: String?

  /// The type of keypair Kubelet will generate for the pod.
  ///
  /// Valid values are "RSA3072", "RSA4096", "ECDSAP256", "ECDSAP384", "ECDSAP521", and "ED25519".
  keyType: String

  /// maxExpirationSeconds is the maximum lifetime permitted for the certificate.
  ///
  /// Kubelet copies this value verbatim into the PodCertificateRequests it generates for this
  /// projection.
  ///
  /// If omitted, kube-apiserver will set it to 86400(24 hours). kube-apiserver will reject values
  /// shorter than 3600 (1 hour). The maximum allowable value is 7862400 (91 days).
  ///
  /// The signer implementation is then free to issue a certificate with any lifetime *shorter* than
  /// MaxExpirationSeconds, but no shorter than 3600 seconds (1 hour). This constraint is enforced by
  /// kube-apiserver. `kubernetes.io` signers will never issue certificates with a lifetime longer than
  /// 24 hours.
  maxExpirationSeconds: Int?

  /// Kubelet's generated CSRs will be addressed to this signer.
  signerName: String
}

/// secret information about the secret data to project
class Secret {
  /// items if unspecified, each key-value pair in the Data field of the referenced Secret will be
  /// projected into the volume as a file whose name is the key and content is the value. If specified,
  /// the listed keys will be projected into the specified paths, and unlisted keys will not be present.
  /// If a key is specified which is not present in the Secret, the volume setup will error unless it is
  /// marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
  items: Listing<Item>?

  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?

  /// optional field specify whether the Secret or its key must be defined
  optional: Boolean?
}

/// serviceAccountToken is information about the serviceAccountToken data to project
class ServiceAccountToken {
  /// audience is the intended audience of the token. A recipient of a token must identify itself with an
  /// identifier specified in the audience of the token, and otherwise should reject the token. The
  /// audience defaults to the identifier of the apiserver.
  audience: String?

  /// expirationSeconds is the requested duration of validity of the service account token. As the token
  /// approaches expiration, the kubelet volume plugin will proactively rotate the service account token.
  /// The kubelet will start trying to rotate the token if the token is older than 80 percent of its time
  /// to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
  expirationSeconds: Int?

  /// path is the path relative to the mount point of the file to project the token into.
  path: String
}

/// quobyte represents a Quobyte mount on the host that shares a pod's lifetime. Deprecated: Quobyte is
/// deprecated and the in-tree quobyte type is no longer supported.
class Quobyte {
  /// group to map volume access to Default is no group
  group: String?

  /// readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to
  /// false.
  readOnly: Boolean?

  /// registry represents a single or multiple Quobyte Registry services specified as a string as
  /// host:port pair (multiple entries are separated with commas) which acts as the central registry for
  /// volumes
  registry: String

  /// tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte
  /// volumes, value is set by the plugin
  tenant: String?

  /// user to map volume access to Defaults to serivceaccount user
  user: String?

  /// volume is a string that references an already created Quobyte volume by name.
  volume: String
}

/// rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. Deprecated: RBD
/// is deprecated and the in-tree rbd type is no longer supported.
class Rbd {
  /// fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem
  /// type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly
  /// inferred to be "ext4" if unspecified. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#rbd
  fsType: String?

  /// image is the rados image name. More info:
  /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  image: String

  /// keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info:
  /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  keyring: String?

  /// monitors is a collection of Ceph monitors. More info:
  /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  monitors: Listing<String>

  /// pool is the rados pool name. Default is rbd. More info:
  /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  pool: String?

  /// readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info:
  /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  readOnly: Boolean?

  /// secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default
  /// is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  secretRef: SecretRef?

  /// user is the rados user name. Default is admin. More info:
  /// https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  user: String?
}

/// secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is
/// nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes. Deprecated:
/// ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
class ScaleIO {
  /// fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
  fsType: String?

  /// gateway is the host address of the ScaleIO API Gateway.
  gateway: String

  /// protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
  protectionDomain: String?

  /// readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
  /// VolumeMounts.
  readOnly: Boolean?

  /// secretRef references to the secret for ScaleIO user and other sensitive information. If this is not
  /// provided, Login operation will fail.
  secretRef: SecretRef

  /// sslEnabled Flag enable/disable SSL communication with Gateway, default false
  sslEnabled: Boolean?

  /// storageMode indicates whether the storage for a volume should be ThickProvisioned or
  /// ThinProvisioned. Default is ThinProvisioned.
  storageMode: String?

  /// storagePool is the ScaleIO Storage Pool associated with the protection domain.
  storagePool: String?

  /// system is the name of the storage system as configured in ScaleIO.
  system: String

  /// volumeName is the name of a volume already created in the ScaleIO system that is associated with
  /// this volume source.
  volumeName: String?
}

/// secretRef references to the secret for ScaleIO user and other sensitive information. If this is not
/// provided, Login operation will fail.
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// secret represents a secret that should populate this volume. More info:
/// https://kubernetes.io/docs/concepts/storage/volumes#secret
class Secret {
  /// defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an
  /// octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and
  /// decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within
  /// the path are not affected by this setting. This might be in conflict with other options that affect
  /// the file mode, like fsGroup, and the result can be other mode bits set.
  defaultMode: Int?

  /// items If unspecified, each key-value pair in the Data field of the referenced Secret will be
  /// projected into the volume as a file whose name is the key and content is the value. If specified,
  /// the listed keys will be projected into the specified paths, and unlisted keys will not be present.
  /// If a key is specified which is not present in the Secret, the volume setup will error unless it is
  /// marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
  items: Listing<Item>?

  /// optional field specify whether the Secret or its keys must be defined
  optional: Boolean?

  /// secretName is the name of the secret in the pod's namespace to use. More info:
  /// https://kubernetes.io/docs/concepts/storage/volumes#secret
  secretName: String?
}

/// storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes. Deprecated:
/// StorageOS is deprecated and the in-tree storageos type is no longer supported.
class Storageos {
  /// fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  fsType: String?

  /// readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in
  /// VolumeMounts.
  readOnly: Boolean?

  /// secretRef specifies the secret to use for obtaining the StorageOS API credentials. If not
  /// specified, default values will be attempted.
  secretRef: SecretRef?

  /// volumeName is the human-readable name of the StorageOS volume. Volume names are only unique within
  /// a namespace.
  volumeName: String?

  /// volumeNamespace specifies the scope of the volume within StorageOS. If no namespace is specified
  /// then the Pod's namespace will be used. This allows the Kubernetes name scoping to be mirrored
  /// within StorageOS for tighter integration. Set VolumeName to any name to override the default
  /// behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do
  /// not pre-exist within StorageOS will be created.
  volumeNamespace: String?
}

/// secretRef specifies the secret to use for obtaining the StorageOS API credentials. If not specified,
/// default values will be attempted.
class SecretRef {
  /// Name of the referent. This field is effectively required, but due to backwards compatibility is
  /// allowed to be empty. Instances of this type with an empty value here are almost certainly wrong.
  /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  name: String?
}

/// vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine. Deprecated:
/// VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type are redirected to the
/// csi.vsphere.vmware.com CSI driver.
class VsphereVolume {
  /// fsType is filesystem type to mount. Must be a filesystem type supported by the host operating
  /// system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  fsType: String?

  /// storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the
  /// StoragePolicyName.
  storagePolicyID: String?

  /// storagePolicyName is the storage Policy Based Management (SPBM) profile name.
  storagePolicyName: String?

  /// volumePath is the path that identifies vSphere volume vmdk
  volumePath: String
}
